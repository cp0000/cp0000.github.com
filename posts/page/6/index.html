<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | </title>
<meta name="keywords" content="">
<meta name="description" content="Posts - ">
<meta name="author" content="">
<link rel="canonical" href="/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<link rel="icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="mask-icon" href="safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>超分FSRCNN的简介
    </h2>
  </header>
  <div class="entry-content">
    <p>这是一篇译文，原文Review:FSRCNN(Super Resolution)
本文主要用来概述一篇实时超分辨率的实现FSRCNN，全称Fast Super-Resolution Convolutional Neural Network，FSRCNN 发表于2016年的ECCV，目前为止有近300次的引用。 FSRCNN有着一个相对浅的网络结构，浅网络层让我们比较好理解每一个网络层的用途。与SRCNN相比，它重建后的图像质量更高。
对比SRCNN，FSRCNN-s(FSRCNN小模型版本)，FSRCNN-s 有着更好的PSNR（图像质量），更快的处理时长。 对比 SRCNN-Ex（SRCNN优质版本）和 FSRCNN，FSRCNN的结果PSNR更好，处理速度更快。 所以，来看下FSRCNN是如何达到质量和速度双优的
下文包含如下内容：
SRCNN 简述 FSRCNN 网络架构 如何利用 1x1 卷积对网络进行压缩和扩大 如何利用多个 3X3 卷积实现非线性映射 对比实验 结论 上图是 SRCNN 和 FSRCNN 的网络架构图。其中 Conv(f,n,c)表示该卷积： 卷积大小为fxf， 有n个过滤器以及c个输入通道。
1. SRCNN简述 SRCNN 的处理过程如下：
对输入图片利用双立方采样做上采样，使得其分辨率为目标分辨率 然后分别利用 9x9, 1x1, 5x5 的卷积来提高图片质量。其中 1x1 卷积是用来把低分辨率（LR）图像向量非线性映射为高分辨率 (HR) 图像向量. 计算复杂度为：
计算复杂度和HR图像大小成线性比例，SHR。HR图像越大，复杂度越高。
2. FSRCNN 网络结构 FSRCNN 包含如下五个主要处理步骤：
特征提取：利用一个 5x5 卷积代替 SRCNN 中的双立方差值 压缩：利用 1x1 卷积把特征层从 d 压缩为 s，其中 s 小于 d 非线性映射：多个 3x3 网络层代替单个的宽网络层 扩大： 1x1 卷积把特征层从 s 扩大为 d 反卷积： 利用 9x9 过滤器重建 HR 图像 以上结构就是 FSRCNN(d,s,m)....</p>
  </div>
  <footer class="entry-footer"><span title='2018-11-06 00:24:40 +0000 UTC'>November 6, 2018</span></footer>
  <a class="entry-link" aria-label="post link to 超分FSRCNN的简介" href="/posts/review-fsrcnn/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>活到30
    </h2>
  </header>
  <div class="entry-content">
    <p>有一天我做了一个恐怖的梦，梦见我32岁了。然后当我醒来，发现自己只有23岁，就放心了。但是后来我真的从梦里醒来，发现自己确实是32岁了。时间过得很快，20岁是人生的巅峰状态，从那以后我们就开始走下坡路了。 – 电影《before the sunset》
少年时听长辈说某件事是10年之前发生的了，会觉得：“哇，10年啊，好久之前发生的事情啊”。如今才发现，10年之前发生的事情却仿佛就在眼前。08年的夏天，我刚上完大一，暑假没事在家里待着，每天守着电视看北京奥运会。电视里各种各样的奥运项目让人应接不暇，看着每个运动员健康矫捷美丽的身姿，我心想人应该活的如此健康快乐才是。
你发现每个你遇到的人，都尝试把环境变得更好，赚更多钱，赢得更多尊重，得到更多的赞赏，这真令人精疲力尽。 – 电影《before the sunset》
11年从大学毕业之后，我便入了程序员这个行当；这是一个适合平民百姓，没啥背景出身的人干的行业。在这个行业只要你技术好，为人靠谱，可以靠着这门手艺安身立命。程序员工作中，和机器打交道多过和人打交道，这样想来我算是误打误撞入了一个和我性格挺搭的行业。 七年多的程序员生涯，我有过一些那种恍然大悟，让人分泌多巴胺的快乐时刻。
只是我最近在思考，程序员工作的意义到底在哪里？可能我所在的行业不是那种基建性质的系统软件开发，程序员在日常生活中，大多数时候做的事情只是担当老板，产品，运营同事们需求的实现者。当中除了如何实现有自己的主见之外，要实现什么完全是听别人的指挥。这听起来是一份没有honor的行当。不过有人会说，其实产品，运营，和其他各种各样形形色色的行业，多数时刻我们都是执行任务的角色。我们受制于人，每天按部就班，小心翼翼的处理事情，保证问题不要出在自己身上。工作的意义对于多数人来讲不过是需要把牛奶和面包放在自家的桌子上，喂养老人，孩子和自己。honor不重要，肚子饿比较重要。所以对饥饿的恐惧感，无形的督促我们每天早起晚归，拼命工作挣钱。
活在当下，我们好像生来就对所有的事情不满。一直想改善自己的状态，一个欲望达成后，下一个有自然浮现。– 电影《before the sunset》
我对死亡最为恐惧是在七八岁的时候。那段日子，晚上关灯睡觉之后，我脑子都会想人要是死去之后，就什么都没有了。不管这世界如何精彩，天上的星星如何闪亮，宇宙如何变化，这一切都和一个死去的人没有一丁点关系。死去，意味着不存在了，你所有的思想，记忆，喜怒哀乐都不复存在了。每每想到此，我就特别的恐惧，恐惧那种不存在。这种恐惧，最近在早晨的梦里又出现了几次, 对不存在的无法接受又萦绕在脑中。不过也许人长大了，也就麻木了，洗漱之后，该上班上班，平日里嘈杂忙碌的生活会帮你忘却这种恐惧。
人到30，进入而立。有那么一瞬间，会觉得一切只能如此了，就按部就班的安稳地活着吧。只是希望自己在忙着挣钱，忙着处理各种各样生活工作中问题的时候，不要忘了Steve Jobs的这段话：
“Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma – which is living with the results of other people’s thinking. Don’t let the noise of other’s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition....</p>
  </div>
  <footer class="entry-footer"><span title='2018-11-04 20:08:40 +0000 UTC'>November 4, 2018</span></footer>
  <a class="entry-link" aria-label="post link to 活到30" href="/posts/30/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>音频编解码以及音乐GPU实时可视化效果实现
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 在一些音乐播放器上（如上学时候用的播放器千千静听）会有一排 直方图 随着音乐节奏忽高忽低的跳动。你会好奇这个直方图的跳动是随着音乐的什么属性来做变换的，貌似有时候和音乐的节奏还挺搭的。要解释清楚这个问题，首先得了解什么声音，以及声音的原理。
声音 声音的原理 根据维基百科上所述：声音是一种波动；当演奏乐器、人说话或者敲击桌面时，声音的振动会引起介质——空气分子有节奏的振动，使周围的空气产生疏密变化，形成疏密相间的纵波，这就产生了声波，这种现象会一直延续到振动消失为止。
声音作为波的一种，频率和振幅就成了描述波的重要属性，频率的大小与我们通常所说的音高对应，而振幅影响声音的大小。声音可以被分解为不同频率不同强度的正弦波的叠加。这种变换（或分解）的过程，称为傅立叶变换(Fourier Transform)。
所以到这里，我们大致明白了音乐播放器上面的直方图其实是声音的频率和振幅的统计图。
声音的特性 响度（loudness）：人主观上感觉声音的大小（俗称音量），由“振幅”（amplitude）和人离声源的距离决定，振幅越大响度越大，人和声源的距离越小，响度越大。（单位：分贝dB） 音调（pitch）：声音的高低（高音、低音），由“频率”（frequency）决定，频率越高音调越高（频率单位Hz（hertz），赫兹)，人耳听觉范围 20～20k Hz。20Hz以下称为次声波，20k Hz以上称为超声波）例如，低音端的声音或更高的声音，如细弦声。频率是每秒经过给定点的声波数量，它的测量单位为赫兹。1000Hz表示每秒经过给定点的声波有1000个周期 音色（Timbre）：又称音品，波形决定了声音的音色。声音因不同物体材料的特性而具有不同特性，音色本身是一种抽象的东西，但波形是把这个抽象直观的表现。音色不同，波形则不同。典型的音色波形有方波，锯齿波，正弦波，脉冲波等。不同的音色，通过波形，完全可以分辨的。 乐音：有规则的让人愉悦的声音。噪音：从物理学的角度看，由发声体作无规则振动时发出的声音； 音频编解码 音频的编解码器需要分成硬件，软件两个部分讨论。硬件部分，音频编码器芯片（ADC）会把接收到的声波转换成PCM数据, 由于PCM占用存储资源太大，不利于传输和存储，所以需要利用音频编解码器软件对PCM数据进行压缩，得到如 FLAC/MP3/OGG 的音频文件。当我们播放一段数字音频文件的时候，则需要先进行软解码，也就是对压缩过的音频文件（FLAC/MP3/OGG）先解码成PCM，然后传送解码后的PCM给音频解码器（DAC），解码器将数字信号转换为模拟信号。
音频硬编码过程 信号的数字化就是将连续的模拟信号转换成离散的数字信号， 一般需要完成采样、量化和编码三个步骤,如下图所示。
采样是指用每隔一定时间间隔的信号样本值序列来代替原来在时间上连续的信号。 量化是用有限个幅度近似表示原来在时间上连续变化的幅度值，把模拟信号的连续幅度变为有限数量，有一定时间间隔的离散值。 编码则是按照一定的规律，把量化后的离散值用二进制数码表示。 上诉数字化过程称为脉冲编码调制（Pulse Code Modulation，缩写PCM）
PCM 的码率 采样率值 × 采样大小值 × 声道数 bps = 码率 例如: 一个采样率为44.1KHz，采样大小为16bit，双声道的PCM编码的WAV文件，它的数据速率则为 44.1K×16×2 =1411.2 Kbps。这表示存储一秒钟采样率为44.1KHz，采样大小为16bit，双声道的PCM编码的音频信号，需要176.4KB的空间，1分钟则约为10.34M MP3 MP3全称是MPEG-1orMPEG-2 Audio Layer III，它被设计来大幅降低音频数据量，它舍弃PCM音讯资料中，对人类听觉不重要的资料，从而达到了压缩成较小的档案。而对于大多数用户的听觉感受来说，MP3的音质与最初的不压缩音频相比没有明显的下降。
音频处理 音频傅立叶变换 了解了声音和音频编解码的基础知识之后，我们可以开始对音频进行相关应用处理了。那如何处理音频呢？首先用Audacity软件打开一段音频，会看到如下图所示的波形图。你会想，这乱糟糟，看起来没啥规律可循的波形的该如何处理。
就像我们处理图片的时候，会把像素点颜色分解成RGB三个通道（或者YCbCr,Lab 等其他颜色空间）进行处理一样，在处理音频的时候，我们需要对音频的波形进行分解。根据声音的特性，不同物体发出的声音频率范围是不一样的，如下图是不同乐器的频率范围：
所以我们可以把音频从时域转换到频域，然后对分解出来的各个频率进行操作。这里需要借助傅立叶变换完成音频从时域到频域的转换。
看不懂傅立叶变换的数学公式也没有关系，只要记住下面这张图就好。
如上图，对左边红色的音频时域声波进行傅立叶变换之后，分解成了一系列正弦波。而右边蓝色部分是针对分解的一系列正弦波的统计图，其中横轴是频率，纵轴是振幅。有了这张频谱图，我们可以很方便的处理音频了（如消除某一段频率等等）。
Demo 有了上面对音频做傅立叶变换后的频率数组，我们可以开始去实现一个音乐实时可视化Demo了。考虑到性能，以及跨平台，我们利用GPU搭配OpenGL编程去实现Demo。实现步骤如下图所示：
获取PCM数据 在iOS上，利用AVFoundation中的AVAudioEngine获取音乐的pcmbuffer，然后利用Accelerate framework中提供的DSP信号处理api，对pcmbuffer进行傅立叶变换。
加载音乐 NSString * audioPath = [[NSBundle mainBundle] pathForResource: @&#34;bgm&#34; ofType: @&#34;....</p>
  </div>
  <footer class="entry-footer"><span title='2018-06-16 10:58:22 +0000 UTC'>June 16, 2018</span></footer>
  <a class="entry-link" aria-label="post link to 音频编解码以及音乐GPU实时可视化效果实现" href="/posts/audio/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>失败者才设定目标
    </h2>
  </header>
  <div class="entry-content">
    <p>Learn OpenCV 因为工作需要，我订阅了 Learn OpenCV 的邮件。Learn OpenCV 可以简单描述成是一个教学OpenCV的网站，网站的作者是 Satya Mallick,美国加州大学圣迭戈分校的博士，主要研究计算机视觉。网站上面的教程每个都是从原理和基础知识开始讲解，配合工程实现，直至最终完成Demo。每篇Blog都会配有c&#43;&#43;和python 两个版本的source code，是个非常不错的学习OpenCV的网站。17年下半年开始，网站上也开始教学机器学习，深度学习相关的知识，同样保持了一贯浅显易懂的特点。
Goals are for losers 最近 Learn OpenCV 发送了一份邮件，标题叫Goals are for losers，直译成中文是目标是为失败者设定的。看起来很标题党的感觉，在我们的认知中，设定目标为了帮助我们把梦想实现，任务完成，是通往更好的自己的必经之路，怎么会是为失败者定制的了。
以下是对Goals are for losers这份邮件的翻译：
随着新年的到来，给新的一年设置目标看起来是一件很美妙的事。但如果你想完成某件事，而你只是设定了一个目标，那你大概率会失败。
假设你今年的目标是完全掌握计算机视觉中某个领域的全部知识。那得等到2018年结束的时候你才会知道你的目标是否完成了。如果你没完成目标，在2018年结束的时候，对这个结果，除了叹息接受，你无能为力。
目标是一个滞后的衡量标准, 你需要一个主导衡量标准
什么是主导衡量标准？主导衡量标准指的是能提前告知你每天是否接近目标。像“每天花两小时学习计算机视觉”就是一个主导衡量标准。
为了始终如一地执行主导措施，我们需要的是制定计划。我们的计划可以制定成早上5点到7点学习计算机视觉（美国人民这么拼？？？）。如果某天你没有完成计划，意味着你需要在那个周末加班把时间补起来。在制定计划的时候，我们需要明确定义在什么时间点做什么事情（计划的可执行也很重要，一个无法执行的计划也是没有意义的）。每天花一点时间这种计划是不会起作用的。
坚持执行计划，目标自然会达成，否则目标就是幻想。
我非常同意上述的观点，一定要为设定的目标制定详细的执行计划，然后按照计划一丝不苟的完成，这样目标才能达成。想来惭愧，我在17年6月份花了 ¥2000.00 参加了FaceAI的课程，但因为没有具体的计划，也缺少明确的目标，导致我购买的这个课程一点知识都没有学习到。
以上。</p>
  </div>
  <footer class="entry-footer"><span title='2018-01-03 19:31:06 +0000 UTC'>January 3, 2018</span></footer>
  <a class="entry-link" aria-label="post link to 失败者才设定目标" href="/posts/goals-are-for-losers/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>我的2017
    </h2>
  </header>
  <div class="entry-content">
    <p>2017年还剩一个月，这一年马上就要走完。年初的计划如果此时还没有开始做，想必也来不及在2017去完成了。所以在12月的开头，总结一下这一年发生的事情，想想其实也不算太早。
Life is Short “时间真的过得太快了“，是人们在年尾回顾一年所作所为时最常感叹的一句陈词滥调。其实，每个人都知道时间流逝，人生苦短。不过仔细想想，当我们在抱怨时间过得太快的时候，是真的在抱怨时间流逝嘛？还是在为自己这一年来碌碌无为，浑浑噩噩所苦恼？Paul Graham在他的博客里提出一个很有意思的假设： 假如我们人类的寿命是现在的10倍，那我们还会感叹人生苦短么？这个假设目前无从验证，但如果感叹人生苦短的本质是苦恼于自己的碌碌无为，那我们应该还是会感叹时间飞逝，即便我们能活800年。
一个可以稍微减轻life is short的解法是不要等待，想到了就去做。诸如明天再进行体育锻炼，下个礼拜再给父母打电话，下个月再开始学习新技术，明年再思考自己到底想做什么等等这些需要以后再去做的事情，最好能当下处理掉。我们不应该感叹于时光飞逝，自己却什么都没做；而应该满足于逝去的时间我都在做我想做，喜欢做的事情上。感叹于物理现象是没有意义的。
出行 2017年我去了美国和澳大利亚。年初的时候是没计划今年会去澳大利亚和美国。去澳大利亚是在五月份，主要目的是旅游。那次出行，我们住在墨尔本城市里面，主要是在维多利亚州活动。维多利亚州到处都是平坦辽阔的草原，上面牛羊成群，真的是一块完美的畜牧地。旅行中见到了小企鹅，树懒，美丽的澳洲风光，可就是没看到袋鼠。墨尔本这座城市也让人很喜欢，虽说澳洲是个移民国家，没什么历史，但墨尔本给人感觉是一座很有历史感的城市。它不是很大，但很美，还有一种莫名其妙的不知道从哪里来的亲切感。在城市广场附近，我远远的看到了澳网球场，作为一个德约科维奇的球迷，没能参观他最为成功的一块球场，略微有点遗憾。相比于墨尔本，黄金海岸给我的感觉是个典型的旅游海岛型城市，坐直升飞机俯览整个黄金海岸，真的很美。行程中，我不止一次的羡慕这块土地的人们，他们的地理环境比起我们中国真的好太多。
去美国是在8月下旬的时候，原因是公司和苹果合作参与iPhone X的新特性封闭开发。凭借着自己三脚猫的英语口语，过了美国海关，搭上出租车来到圣何塞的库比蒂诺和同事汇合。硅谷整体给人的观感是一个大农村，公共交通设施很差，物价很高。天气也比较干旱，一开始会不太喜欢那里的天气，但呆久了就觉得还挺好。硅谷的建筑都不高，一般都是四五层楼，不像国内的办公楼动辄二三十层。那是段很有意思的经历。
一些推荐 ###书 17年还是读了一些蛮有意思的书，其中人物传记比较多，有
《鞋狗》 《硅谷钢铁侠：埃隆马斯克的冒险人生》 《成为乔布斯》 《曾国藩家书》 《毛泽东传》 其他的书
《死之枝》 《独裁者手册》 《拆掉思维里的墙-原来我还可以这样活》 《平凡的世界》 播客 播客听的比较多是跟李如一先生或多或少有关系的一些博客, 推荐的有：《一天世界》，《灭茶苦茶》，《博物志》，《硬影像》，《太医来了》，《声东击西》，《迟早更新》，《简单心理》
影视 电影《赴汤蹈火》，《爱乐之城》不错；美剧《Better Call Saul》，《Mr. Robot》，《GOT》都不错。
以上。</p>
  </div>
  <footer class="entry-footer"><span title='2017-12-03 12:58:39 +0000 UTC'>December 3, 2017</span></footer>
  <a class="entry-link" aria-label="post link to 我的2017" href="/posts/my-2017/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>活到29
    </h2>
  </header>
  <div class="entry-content">
    <p>“婚姻是一座围城，城外的人想进去，城里的人想出来.” – 钱钟书 《围城》
我还没有结婚，所以也无从体验婚姻是否真如钱先生所说的那样，是一座围城。倒是这世上许许多多的事情，还真如这句话所言，城外的人想进去，城里的人想出来。前阵子看到一篇文章，讲的是在美国硅谷生活工作的35岁左右男性面临的职业危机，或者说是两难吧。要么继续呆在美国，但职业天花板明摆在那里，生活也是一眼到头。选择回国，会有更具吸引力的薪资，权利，机会，但年轻的时候拼了命来美国是否又变得没有意义；而且老婆孩子还得继续留在美国，自己异地工作，没法照顾家庭，夫妻，父子关系会否变得浅薄起来。总之就是对现状无法感到满意，着急改变。这应该是一个很典型的围城思维。就像国内的程序员会觉得能去美国硅谷的大公司，如Google,Apple,Facebook工作才算是真正成功的程序员。不但可以肉身翻墙，赚取美金，还可以享受“民主与自由”。但身处美利坚的同志们可能也有自己的烦恼，比如如上文案例所讲的，事业发展有瓶颈，机会不如在国内多，父母亲留在国内，没法照顾，等诸如此类的。
的确，我们成长的过程中，总是在经历着各种各样的围城事件。去大城市打拼的人觉得工作生活压力太大，留在小城市安逸舒服，反之小城市的人觉得大城市繁华，机会多，挣钱多。搞计算机的觉得其他行当的人没这么累，其他行当的人觉得这几年搞计算机的人挣得多。呆在大公司上班的人觉得自己创业的人酷，什么都自己说的算，创业的人却在抱怨投资人像祖宗一样难搞，自己每天都在透支着自己的身体，还是留在大公司打一份工，省心。总之，诸如此类，不甚枚举。每个人在某个阶段都会有围城思维，我经历过，其他人肯定也经历过。
程序员对解决问题这件事情有着近乎偏执的爱好，行文到这里，该是到写如何破解围城思维的时候了。但有些事情就像今年奥斯卡最佳男主角所演的《海边的曼彻斯特》这部电影中表述的故事一样，注定是没有答案，无从解决的。围城就是在那里，每个人在生命的各个阶段都得面对自己的围城，是进去，还是出来，亦或是出来后再进去，只能全凭自己的判断。运气好的，生活继续，吃饱睡足，心满意足；运气不好的，只能怪自己为何出城，老实呆着不好嘛之类的。
活到二十九，而立之年。今年的生日过的分外没劲，可能日子就是这样，年纪越大越觉得过生日是一种折磨。时间流逝，所谓理想，爱好都会随之消散，到最后只剩下买房，结婚生子，赡养老人等社会责任让你继续上路，不至于垮掉。</p>
  </div>
  <footer class="entry-footer"><span title='2017-10-29 22:56:05 +0000 UTC'>October 29, 2017</span></footer>
  <a class="entry-link" aria-label="post link to 活到29" href="/posts/29/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Learning OpenGL：光照
    </h2>
  </header>
  <div class="entry-content">
    <p>颜色 计算机如何表达现实世界中五彩滨纷的颜色？答案是用红，绿，蓝（缩写RGB）三个分量来数字化颜色。但我们在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它反射的（Reflected）颜色。也就是说，那些不能被物体所吸收的颜色就是我们能够感知到的物体颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的。如果我们将白光照在一个红色的衣服上，这个红色的衣服会吸收白光中除了红色以外的所有子颜色，而不被吸收的红色光被反射到我们的眼中，让这件衣服看起来是红色的。
颜色反射的定律被直接运用到图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色。在OpenGL中，我们将两个颜色向量作分量相乘，结果就是最终的颜色向量了：
vec3 lightColor(1.0,1.0,1.0); vec3 clothingColor(0.0,0.5,0.0); vec3 result = lightColor * clothingColor; // (0.0, 0.5, 0.0); 我们定义物体的颜色为物体从一个光源反射各个颜色分量的大小.我们可以使用不同的光源颜色来让物体显现出意想不到的颜色。
##基础光照
现实世界的光照极其复杂，而且受诸多因素影响，计算机有限的计算能力无法模拟。因此在OpenGL的光照使用的是简化的模型，对现实的情况进行近似模拟。这些光照模型是基于我们对光的物理特性的理解。冯氏光照模型是其中一个模型，冯氏光照模型主要由3个分量组成：环境（Ambient），漫反射（Diffuse）和镜面（Specular）光照。如下图：
环境光照（Ambient Lighting）:在黑暗的情况下，现实世界通常也仍有一些光亮，所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。 漫反射光照（Diffuse Lighting）：模拟光源对物体的方向性影响。它是冯氏光照模型中视觉上最显著的分量。物体的莫一部分越是正对着光源，它就会越亮。 镜面光照（Specular Lighting）：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。 环境光照 我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，如此即使场景中没有直接的光源也能看起来存在有些发散的光。
void main() { float ambientStrength = 0.1; vec3 ambient = ambientStrength * lightColor; vec3 result = ambient * objectColor; gl_fragColor = vec4(result, 1.0); } 漫反射光照 漫反射对物体产生显著的视觉影响。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。
光源发出的光线落在物体的一个片段上，我们需要计算这个光线是以什么角度接触到这个片段的。为了测量光线和片段的角度，需用到一个叫做法向量（Normal Vector）的东西，它是垂直于片段表面的一个向量。点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向不同，这些片段被照亮的情况也不同。所以，计算漫反射光照需要：
法向量：一个垂直于顶点表面的向量 定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。 法向量 法向量是一个垂直于顶点表面的（单位）向量。由于顶点本身并没有表面，我们利用它周围的顶点来计算出这个顶点的表面。一个三角形的法线是一个长度为1并且垂直于这个三角形的向量。而顶点的法线，是包含该顶点的所有三角形的法线均值。
###漫反射光照 每个顶点有了法向量，但我们仍然需要光源额度位置向量和片段的位置向量。由于光源的位置是一个静态变量，故简单在片段着色器中声明为uniform：
uniform vec3 lightPos; 渲染的时候，设置lightPos就可以了。 最后，我们还需要片段的位置。我们会在世界空间中进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵来把它变换到世界坐标系。如下：
varying vec3 fragPos; varying vec3 normal; void main() { gl_Position = projection * view * model * vec4(aPos, 1....</p>
  </div>
  <footer class="entry-footer"><span title='2017-10-04 17:39:47 +0000 UTC'>October 4, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Learning OpenGL：光照" href="/posts/opengl-lighting/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>读书笔记：《鞋狗》
    </h2>
  </header>
  <div class="entry-content">
    <p>人生不一定会赢，而我就是不想输。 –菲尔·奈特
11-12赛季的英超，阿森纳客场对阵切尔西。范佩西在比赛中上演帽子戏法，帮助阿森纳5-3赢得比赛。那是个阳光明媚的秋日午后，破门之后，范佩西在斯坦福球场上振臂高呼，一时间场外球迷高呼其名，为其呐喊助威，就像欢呼得胜回朝的将军一般。那一刻，我想这是足球这项运动带给职业球员最大的吸引力吧，或许也是竞技体育带给运动员们最大的吸引力。以前我觉得可能就是我一个人这么幻想过，成为一个杰出的运动员，在赢得比赛的那个刹那，场下的千万观众为你欢呼呐喊；直到最近看了NIKE的创始人菲尔·奈特的亲笔自传《Shoe Dog: A Memoir by the Creator of Nike》，在书中的前几章我找到了一直以来关于运动内涵的最好描述。
以下是两段摘录：
球在半空时，双方拳击手感觉到一个回合结束的铃声即将敲响时，或是跑者靠近终点，观众集体站起来时，那些事情就处于某个我们所不清楚的地方。在决定胜负前最激动人心的半秒内，显然会产生一种愉悦感。我想要的就是那个，无论到底是什么，我就想让那种感觉充实我的人生，填满我每天的生活。
运动可以让人们感受不同的生活，参与到别人的胜利中去，甚至体验失败。运动达到高潮的时候，粉丝的精神与运动员的精神融合在一起，这种情感的集合和转移，神秘主义者称其为合一
对于体育的热爱是菲尔·奈特选择去销售运动鞋的初衷，自传中讲述了NIKE是如何一步一步从无到有，并最终上市的；从最开始代理日本鬼冢虎鞋子往美国销售，到研发NIKE鞋子，并打败当时的霸主Adidas。作者在书中没有对自己成功进行任何粉饰，而是把大量篇幅拿来讲述自己如何和银行家较量，和债主周旋，和供应商协调，以及和政府部门官僚的斗争。作者真实记录了一个企业的成长过程，像众人坦诚公司最初的发展是非常混乱，危险，没有章法的。每一天都挣扎在破产的边缘（现金流就是零售业的生死线）。作为公司的创始人，菲尔·奈特早期没有在商业上指导江山，没有各种方法论，他每天都在遇到各种各样的挑战，而他能做的就是坚持下去；当然光坚持也没用，作为创始人，奈特要做的且唯一能做的就是想尽一切办法去解决问题。过程你会发现，企业不是一个人能做起来的，奈特需要找来各种各样的人，组合起来一个战斗力十足的创始团队。团队中有人擅长开疆拓土，打开新的市场；有人擅长研发新的鞋子，树立技术堡垒；有人擅长和政府部门打交道，搞定华盛顿那帮家伙。总之一个好汉三个帮，要想做成一个企业，没有得力的帮手是不可能的。勇敢，敏锐，合作，极大的耐力，以及全身心的投入是我读完该书对菲尔·奈特的性格理解。
书的最后一章，是奈特关于企业，以及自己生活的一些感性描写和反思。
我想告诉大家要按下暂停键，花时间努力思考一下要如何度过一生，想要和谁一起度过剩余的40年。我会告诉20岁左右的青年不要为了一份工作，专业甚至职业而安定下来，一定要寻求内心的冲动。即使你不知道其中的含义，也要坚持追寻。如果你追随自己内心的冲动，将会更能忍受疲惫，每一次失望都会成为你的动力，需要攀登的高峰也会变得微不足道起来。
你会发现这段话和乔布斯那段著名的斯坦福大学的毕业演讲和其相似：
The only way to do great work is to love what you do. If you haven’t found it yet, keep looking.
追随内心的冲动是两位伟大企业家的共性所在。
以上！</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-06 19:24:18 +0000 UTC'>August 6, 2017</span></footer>
  <a class="entry-link" aria-label="post link to 读书笔记：《鞋狗》" href="/posts/shoe-dog/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>冈仁波齐
    </h2>
  </header>
  <div class="entry-content">
    <p>去看了电影《冈仁波齐》，一开始倒不是因为想了解这部电影所宣扬的藏族信仰是为何物，而是因为朴树的片尾曲《No Fear In My Heart》。想来从高一的时候接触到朴树，从听《Colorful Days》，《傲慢的上校》，《生如夏花》，到现在已然13年了。令人兴奋的是，朴树这两年回来了。
很难讲《冈仁波齐》一部好看的电影，她是一部很特别的电影，看完电影我会觉得还是很值得一看。整个电影给我最大的冲击瞬间是他们从村里出发朝圣去冈仁波齐的时候。看到影片中出现了拖拉机，我以为他们会坐着拖拉机一路开过去。但又觉得坐拖拉机不能算朝圣吧，那怎不能走着过去吧，那么远，而且在高原上，得走多久才能到。所以当他们卧倒开始磕头前行的时候，我被震住了，说不出话来。是啊，在这个出行飞机高铁，挣钱越快越好，什么都讲究利益的年代，你看到一行人，一路从家乡磕头2000多里去圣地，很难不被这种行为所震动。
大多数国人是无宗教信仰者，当然我也是。我不懂宗教，更不懂藏传佛教，可能我还是个没有信仰的人。电影中可以明显感受到宗教给藏民带来的影响，一个最直接的感受是，他们都好平静，好平静。朝圣路上，大家生活在一起，无论晴天雪天，每天磕头朝拜，孕妇生完小孩后，回到队伍继续朝圣之路；老人去世了，举行完葬礼，大家继续朝圣。好像没有什么事情能阻止他们，就好像没什么事情能打破他们的平静。孩子出生的喜悦，老人去世的悲伤，都很平静，没有我们红白喜事的那种热闹，嘈杂，笑声朗朗或哀嚎震天。
坦率的说，我不觉得他们的生活方式就是好的，但我很羡慕他们表现出来的那种平静和笃定，那种生活在现代社会的人，很难拥有的不慌不忙。</p>
  </div>
  <footer class="entry-footer"><span title='2017-07-02 15:08:30 +0000 UTC'>July 2, 2017</span>&nbsp;·&nbsp;cp</footer>
  <a class="entry-link" aria-label="post link to 冈仁波齐" href="/posts/kangrinboqe/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Learning OpenGL：帧缓冲对象
    </h2>
  </header>
  <div class="entry-content">
    <p>背景 使用OpenGL渲染时，一般情况下我们使用的是默认的帧缓冲区（一般指的是 FrameBuffer Object Id 为 0）。但如果我们想实现一些后处理操作，如边缘检测，镜面，离屏渲染等，就需要我们自己创建自定义帧缓冲区，使用自定义帧缓冲区来进行后处理操作。
FBO 在OpenGL中，渲染管线中的顶点，纹理等经过一系列的处理之后，最终显示在2D屏幕设备上，渲染管线的最终目的地是帧缓冲区。OpenGL中使用到帧缓冲包括三个：颜色缓冲，深度缓冲，模版缓冲。系统自身会创建一个默认缓冲区，OpenGL允许我们手动创建自定义帧缓冲区，并将渲染结果重定向到这个缓冲区。
帧缓冲对象中包括两种类型的附加图像：纹理图像和RenderBuffer图像。附加纹理时，OpenGL渲染到这个纹理图像上，在着色器中可以访问这个纹理图像。附加RenderBuffer时，OpenGL执行离屏渲染（offscreen, rendering）。
帧缓冲对象可以附加多个缓冲区，且可灵活地在缓冲区中切换。帧缓冲对象中包含一个以上的颜色附加点，而深度和模版都只有一个附加点。如下图所示：
&gt;注：OpenGL es 2.0 也只有一个颜色附加点 从上图可知，帧缓冲对象本身不包含任何缓冲对象，实际上是通过附加点指向实际的缓冲对象。
创建 FBO 创建和销毁FBO的步骤很简单：
void glGenFramebuffers(GLsizei n, GLuint * ids); void glDeleteFramebuffers(GLsizei n, const GLuint * ids); 将FBO绑定到目标对象：
void glBindFramebuffer(GLenum target, GLuint id) target分为三种类型：GL_FRAMEBUFFER-缓冲区用来进行读和写操作；GL_READ_FRAMEBUUFER–缓冲区支持glReadPixels读操作；GL_DRAW_FRAMEBUFFER-缓冲区支持渲染，清除操作。 id 即为创建出来的帧缓冲id 通过绑定GL_FRAMEBUFFER,接下来所有的读和写操作都是在当前的帧缓冲上进行。
OpenGL要求，一个完整的FBO需要满足以下条件：
至少附加一个缓冲区（颜色，深度或模版）
至少有一个颜色附加
所有的附加必须完整（预分配了内存）
if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) 来判断一个FBO是否完整
每个缓冲区的采样需要一致
接下里所有的渲染操作都将会渲染到当前绑定的帧缓冲中去。由于当前的帧缓冲不是默认帧缓冲，渲染指令将不会影响到屏幕上的显示内容，所以我们把渲染到非默认帧缓冲叫做离屏渲染（off-screen rendering）.为了保证所有的渲染指令最终会呈现在设备屏幕上，我们需要重新绑定激活默认帧缓冲：
glBindFramebuffer (GL_FRAMEBUFFER, 0); 创建纹理附加图像 创建FBO的附加纹理如同平常使用纹理一样，不同的是，这里只为纹理分配空间，而不填充实际纹理图像内容，因为当使用FBO渲染时渲染结果将会写入到我们创建的这个纹理上去
glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture,GLint level); target: 绑定目标，一般为 GL_FRAMEBUFFER...</p>
  </div>
  <footer class="entry-footer"><span title='2017-03-19 14:20:09 +0000 UTC'>March 19, 2017</span>&nbsp;·&nbsp;cp</footer>
  <a class="entry-link" aria-label="post link to Learning OpenGL：帧缓冲对象" href="/posts/framebuffer-object-opengl/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="/posts/page/5/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="/posts/page/7/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href=""></a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
