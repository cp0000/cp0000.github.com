<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Tech | CP WRITINGS</title>
  <meta name="author" content="Pei Cheng">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="CP WRITINGS"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="CP WRITINGS" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="/js/jquery.min.js"></script>
  
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45019001-1', 'topdna.org');
  ga('send', 'pageview');

</script>


</head>


<body>
  <!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0027_Simplified Chinese.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">CP WRITINGS</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="http://traceinvest.com">TraceInvest</a></li>
    
      <li><a href="/categories/essay/">随感</a></li>
    
      <li><a href="/categories/tech/">技术</a></li>
    
      <li><a href="/categories/investment/">理财</a></li>
    
      <li><a href="/categories/life/">生活</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title category">Tech</h2>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-08-30T14:02:42.000Z"><a href="/2015/08/30/openradarstream/">Aug 30 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/30/openradarstream/">Openradar Stream</a></h1>
  

    </header>
    <div class="entry">
      
        <p><img src="http://cp0000.github.io/assets/radardetector2.jpg" alt="Openradar Stream"></p>
<h4 id="写在前面">写在前面</h4>
<p>随着夏天的结束，9月份的到来，又到了苹果秋季发布新iPhone的季节了。我和绝大多数苹果用户一样对新的iPhone自然保留着一份期待。不过理智告诉我这次新的iPhone的release，应该不会给大家带来很大的惊喜。我猜测 iPhone6s 应该是一款针对 iPhone6 的升级产品。就像 iOS 9 是针对 iOS 8的一次升级，苹果公司内部在这一次的迭代中，主要精力应该是会放在“还债”上，之前release了太多的feature，遗留了太多的bug，会在这一次修复掉。</p>
<h4 id="Openradar_stream_的来由">Openradar stream 的来由</h4>
<p>和大多数 iOS developers 一样，我也在第一时间安装了 iOS 9 beta版本。满足了尝鲜感之后，随着而来就是 beta 系统的不稳定，以及各种的bug。用 iOS 9 进行开发的过程中，我遇到了许许多多的坑，对于一些系统的bug，会花费掉我很多的时间去debug。然后，我发现了<a href="http://www.openradar.appspot.com/" target="_blank" rel="external">openradar</a>。一个 open database of radars for Apple bug。从openradar 上，你可以看到其他开发者提交的bug，这当然会为你省去很多的时间，帮助你避免很多的坑。</p>
<p>后来我想我是不是应该做一个自动的脚本，定时的去抓取这个网页上面的信息，然后发到微博上。关注这个微博的人就可以在自己的时间线上面看到最新的bug了。这样做的好处是，一来你了解到bug信息，下次你遇到类似的问题，会联想到之前看过的bug信息，省去大量的时间。二来，刷微博的时候，还顺便学习了新知识，就没那么大的罪恶感了～。为此，我写一个tiny project，auto radarstream。</p>
<h4 id="具体工作">具体工作</h4>
<p>完成openradarstream，有以下事情需要去做</p>
<p><strong>前期工作</strong></p>
<ul>
<li>申请一个微博账号，并申请微博OpenApi，获取到<code>apikey</code>和<code>apisecret</code>。</li>
<li>获取到微博的 accessToken， expires</li>
</ul>
<p><strong>开发工具</strong></p>
<ul>
<li>language: python</li>
<li>database: sqlite</li>
</ul>
<p><strong>细节</strong></p>
<ul>
<li>设置好微博的环境，其中微博的OpenAPI,使用开源库<a href="https://github.com/michaelliao/sinaweibopy" target="_blank" rel="external">sinaweibopy</a></li>
<li>初始化数据库</li>
</ul>
<pre><code>    <span class="function"><span class="keyword">def</span> <span class="title">initDB</span> <span class="params">()</span>:</span>
        <span class="keyword">print</span> <span class="string">'initDB ...'</span>
        db = sqlite3.connect(sqlite_file)
        cursor = db.cursor()
        cursor.execute(<span class="string">'''CREATE TABLE IF NOT EXISTS
                          bugs(id INTEGER PRIMARY KEY, bugid TEXT, status TEXT, originator TEXT, product TEXT, title TEXT)'''</span>)
        db.commit()
</code></pre><ul>
<li><p>获取网站信息，并做相关处理。</p>
<p>  第一步利用 urllib2 获取<a href="http://openradar.appspot.com/" target="_blank" rel="external">openradar</a>主页信息。<br>  第二步对获取到的信息，利用 BeautifulSoap 对<code>html</code>进行解析，得到一个buglist。<br>  第三步，由于网页上面的信息是按时间降序的，而我们是希望最新的bug，在本次最后一个发布，这样这条bug会出现在微博主页时间线的最上头。所以我们这里反转buglist。<br>  第四步，遍历buglist，发布没有发布的bug，并把发布过的bug插入数据库存档。</p>
</li>
</ul>
<p>项目在Github上面的地址：<a href="https://github.com/cp0000/radarstream" target="_blank" rel="external">radarstream</a>。</p>
<h4 id="最后">最后</h4>
<p><strong>To track open radar posts, please follow <a href="http://weibo.com/p/1005051666350201" target="_blank" rel="external">@openradarstream</a></strong></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-08-22T01:52:28.000Z"><a href="/2015/08/22/UICollectionView-Has-Easy-Reording-On-iOS9/">Aug 22 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/22/UICollectionView-Has-Easy-Reording-On-iOS9/">UICollectionViews Now Have Easy Reordering （译）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="iOS_9-0_UICollectionView_拖拽效果实现">iOS 9.0 UICollectionView 拖拽效果实现</h1>
<blockquote>
<p>原文 <a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/" target="_blank" rel="external">UICollectionViews Now Have Easy Reordering</a></p>
</blockquote>
<p>在<code>UICollectionView</code> 刚出来的时候，我就对其产生了很大的兴趣。相比它的大哥 <code>UITableView</code>，它更加容易进行一些自定义的操作。我们组现在在项目中使用 <code>UICollectionView</code> 要多于 <code>UITableView</code>。伴随着 iOS 9 的 release，<code>UICollectionView</code>排序（动态拖拽）更加简单。在这之前，如果想对 <code>UICollectionView</code> 进行动态拖拽是非常困难的，要想实现动态拖拽，需要去做非常多的工作。话不多说，我们看一下新的 API。文章用到的Sample地址<a href="https://github.com/nshintio/uicollectionview-reordering" target="_blank" rel="external">uicollectionview-reordering</a>。</p>
<p>实现拖动排序最简单的办法是使用 <code>UICollectionViewController</code>, 在 <code>UICollectionViewController</code> 中新增了一个属性  <code>installsStandardGestureForInteractiveMovement</code>, 通过添加手势对cells进行重排。该属性是BOOL型，默认值为 YES。     我们所需要做的，只要重载下面这个方法就好了.</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> collectionView(collectionView: <span class="type">UICollectionView</span>,
    moveItemAtIndexPath sourceIndexPath: <span class="type">NSIndexPath</span>,
    toIndexPath destinationIndexPath: <span class="type">NSIndexPath</span>) {
    <span class="comment">// move your data order</span>
}
</code></pre><p>当程序中重载了<code>moveItemAtIndexPath</code>，collectionView 就认为 cell 是可以移动的。</p>
<pre><code>![<span class="link_label">reordering-01</span>](<span class="link_url">http://nshint.io/images/uicollectionview-reordering/1.gif</span>)
</code></pre><p>那如果需要给某一个 <code>UIViewController</code> 中 collection view 实现动态拖动效果，该如何实现呢？事情会变的稍微复杂一点。除了需要实现<code>UICollectionViewDataSource</code>中上面提到的代理方法，还需要重写 <code>installsStandardGestureForInteractiveMovement</code>。不过不用当心，实现起来蛮蛮容易。这里我们需要长按手势<code>UILongPressGestureRecognizer</code>，它能够完全满足拖拽需求。</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> viewDidLoad() {
    <span class="keyword">super</span>.viewDidLoad()
    longPressGesture = <span class="type">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"handleLongGesture:"</span>)
    <span class="keyword">self</span>.collectionView.addGestureRecognizer(longPressGesture)
}

<span class="func"><span class="keyword">func</span></span> handleLongGesture(gesture: <span class="type">UILongPressGestureRecognizer</span>) {

    <span class="keyword">switch</span>(gesture.state) {

    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Began</span>:
        guard <span class="keyword">let</span> selectedIndexPath = <span class="keyword">self</span>.collectionView.indexPathForItemAtPoint(gesture.locationInView(<span class="keyword">self</span>.collectionView)) <span class="keyword">else</span> {
            <span class="keyword">break</span>
        }
        collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)
    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Changed</span>:
        collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view!))
    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Ended</span>:
        collectionView.endInteractiveMovement()
    <span class="keyword">default</span>:
        collectionView.cancelInteractiveMovement()
    }
}
</code></pre><p>这段代码主要是给 collectionView 添加一个长手势识别器，并根据手势的不同状态调用collectionView的相关方法。</p>
<ul>
<li><code>beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)</code>: 该方法在开始拖拽某个cell时被调用</li>
<li><code>updateInteractiveMovementTargetPosition(targetPosition:CGPoint)</code>: 根据手势更新拖拽cell的位置</li>
<li><code>endInteractiveMovement()</code>: 手势结束时调用，结束拖拽</li>
<li><code>cancelInteractiveMovement()</code>: 手势取消时调用，取消拖拽</li>
</ul>
<p>这样就实现了需要的拖拽效果：</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/2.gif" alt="reordering_collection_view"></p>
<p>这段代码出来的效果和 <code>UICollectionViewController</code> 是一致的。很厉害吧，但更厉害的是我们可以用上面的方法对自定义的 collection view layout 进行拖拽。下面我们来实现一个简单的瀑布流。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/3.gif" alt="reordering_waterfall"></p>
<p>昂～，看起来还凑合，但在移动的时候cell的size被改变了呢，如何才能保持cell的size不变呢？ <code>UICollectionViewLayout</code>提供了相关办法可以帮助我们解决这个问题。</p>
<pre><code><span class="input"><span class="prompt">func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],
    withTargetPosition targetPosition: CGPoint,
    previousIndexPaths: [NSIndexPath],
    previousPosition: CGPoint) -&gt;</span> <span class="constant">UICollectionViewLayoutInvalidationContext</span></span>
<span class="input"><span class="prompt">
func invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths(indexPaths: [NSIndexPath],
    previousIndexPaths: [NSIndexPath],
    movementCancelled: Bool) -&gt;</span> <span class="constant">UICollectionViewLayoutInvalidationContext</span></span>
</code></pre><ul>
<li>第一个函数会在 cells 拖拽过程中被调用</li>
<li><p>第二个函数会在拖拽结束时候被调用。有了这些信息，我们可以使用一点小技巧去实现cell size不被改变的功能。</p>
<p>  internal override func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],</p>
<pre><code>  withTargetPosition targetPosition: <span class="built_in">CGPoint</span>,
  previousIndexPaths: [<span class="built_in">NSIndexPath</span>],
  previousPosition: <span class="built_in">CGPoint</span>) -&gt; UICollectionViewLayoutInvalidationContext {

  var context = <span class="keyword">super</span><span class="variable">.invalidationContextForInteractivelyMovingItems</span>(targetIndexPaths,
      withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,
      previousPosition: previousPosition)

  <span class="keyword">self</span><span class="variable">.delegate</span>?<span class="variable">.collectionView</span>!(<span class="keyword">self</span><span class="variable">.collectionView</span>!, moveItemAtIndexPath: previousIndexPaths[<span class="number">0</span>],
      toIndexPath: targetIndexPaths[<span class="number">0</span>])

  <span class="keyword">return</span> context
</code></pre><p>  }</p>
</li>
</ul>
<p>解决方法很直接。获取当前被拖拽的cell的起始indexPath和目标indexPath,然后调用UICollectionViewDataSource代理方法移动当前正在被拖拽的cell。</p>
<p>一个可以拖拽的的collectionView带来体验效果真的非常棒～</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-08-02T03:31:18.000Z"><a href="/2015/08/02/mdfind-note/">Aug 2 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/02/mdfind-note/">Spotlight &amp; MDFind</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="Indexing_服务">Indexing 服务</h4>
<p>Maocx 系统的搜索服务 <code>spotlight</code> 想必大家都用过。它可以很便捷的帮我们找到想要的文件。</p>
<p>先举个例子，在 spotlight 中输入 _loadBlock， 我的电脑会出现以下结果：</p>
<p><img src="http://cp0000.github.io/assets/loadBlock.png" alt="loadBlock"></p>
<p>spotlight 帮我找到了包含 <code>_loadBlock</code> 这个字符串的文件。</p>
<p>想象下，电脑硬盘中存储着如此多的文件，<strong>spotlight 是如何如此快速的查询到包涵这个字符串的文件的？</strong></p>
<p>在查找答案之前，我们不妨自己来试着猜想一下，如果这个功能交给我们自己来做，我们会采用哪种技术方案来实现？<br>关于文件搜索，首先能想到的最简单的方法自然是遍历目录逐个文件对比，使用 <code>find</code> 的方式去查询。不过稍微想一下，如果使用这种方法在整个硬盘上找一个文件，得等多久才能找到一个文件。这肯定不是解决方案。<strong>那答案是什么？</strong></p>
<p>我们不妨先把目光放到<code>搜索</code>这两个字上。提到搜索，首先想到的应该会是Google。而关于Google搜索引擎的工作原理，最简单的解释是：通过代码在全球收集信息，建立词组的索引数据库。Google处理用户的搜索请求，可以简单的理解成在索引数据库中查找结果的过程。<br>那 Macosx 的本地文件搜索会不会也是采取这种索引数据库的方式来实现的？答案是肯定的。Macosx 实现了自己的<code>indexing</code>的索引服务。那什么是<code>indexing</code>索引服务器，简单来讲： Macosx 系统会在平时建立磁盘上所有文件和目录的索引关系，维护出一个索引表，当要查找信息时直接从索引中查询即可。这个索引就好像是一本书的目录一样，我们根据自己要找的内容翻到对应的页面。</p>
<p>当然这当中还有很多复杂的处理过程，如当机器运行时，硬盘的文件产生变化，如何重新加载索引文件。更多的细节，我也没找出相关的文档来得到答案。先留个坑在这里吧。不过我们可以从其他开源的文件查询项目中了解一下业界对于这一块的处理方式。这里推荐 <a href="https://lucene.apache.org/" target="_blank" rel="external">Lucene</a> 给大家研究。（Lucene是一套用于全文检索和搜素的开源项目）。</p>
<h4 id="mdfind">mdfind</h4>
<p>用 spotlight 的图形界面查询文件是很方便.但是我平常的工作过程中，常常需要知道文件的绝对路径，而图形界面并没有显示出来。<strong>关于如何在spotlight界面显示文件的详细路径</strong>，这里有个小 tips，具体操作是：选中某个搜索结果，长按 command 键，此时，界面右下方会出现文件的详细路径。不过如果文件路径太长，界面会显示不全，而且也有很好的没法去拷贝这个路径。</p>
<p><strong>那如何解决文件路径显示不全，无法拷贝文件路径的问题呢？</strong></p>
<p>Macosx 提供了终端执行命令<code>mdfind</code>，我们可以在 terminal 中使用<code>mdfind</code>来进行索引查询。比如要查询出文件内容中包含字符串 “_loadBlock”, 在ternimal中输入以下命令即可：</p>
<pre><code>mdfind 'kMDItemTextContent=<span class="string">"_loadBlock"</span>' 
</code></pre><p>results:</p>
<pre><code>/<span class="keyword">opt</span>/dev/appstore_cracked/StoreKit_headers/SKStorePageViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/appstore_cracked/StoreKit_headers/SKStoreProductViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/iTunesStoreUI.framework/SUWebViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/iTunesStoreUI.framework/SUStorePageViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/iTunesStoreUI.framework/SUPreviewOverlayViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/Preferences.framework/PSLazyImagePromise.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/Frameworks/StoreKit.framework/SKStoreProductViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/Frameworks/StoreKit.framework/SKStorePageViewController.<span class="keyword">h</span>
</code></pre><p>对比终端查询结果和图一中的结果，会发现有两点出入：</p>
<ul>
<li>(1) 图一中的 PrivateFrameworks, Frameworks 整个目录都没有被查出来。这里我猜测应该是Soptlight这个应用是对查询结果进行了筛选，把PrivateFrameworks, Frameworks目录下的文件从查询结果中剔除掉了。</li>
<li>(2) 图一中出现的nsBlocklistService.js，在terminal的查询结果中并没有出现。为了找出原因，我分别查看下”_loadBlock”在各个文件中的上下文，以下是节选</li>
</ul>
<p>nsBlocklistService.js</p>
<pre><code><span class="keyword">this</span>._loadBlocklist();
</code></pre><p>SKStorePageViewController</p>
<pre><code><span class="title">CDUnknownBlockType</span> _loadBlock;
</code></pre><p>看上去问题应该是出在<code>_loadBlock</code>前后是否能跟别的字符串上，修改查询语句</p>
<pre><code>mdfind 'kMDItemTextContent=<span class="string">"_loadBlock*"</span>' 
</code></pre><p>果然可以查询到结果</p>
<pre><code><span class="regexp">/Project/m</span>ozilla-central<span class="regexp">/toolkit/m</span>ozapps<span class="regexp">/extensions/</span>nsBlocklistService.js
</code></pre><p>关于 mdfind 的一些常用查询语法，可参考 <a href="http://osxnotes.net/spotlight.html" target="_blank" rel="external"><code>osxnotes</code></a>，这里列举了大量的例子。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-07-23T13:12:55.000Z"><a href="/2015/07/23/oc-checklist-answers/">Jul 23 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/23/oc-checklist-answers/">Objc Interview Checklist Answers</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="@property中有哪些属性关键字？">@property中有哪些属性关键字？</h4>
<p>nonatomic (thread-unsafe)<br>atomic (default, thread safe)</p>
<p>strong<br>weak<br>assign<br>copy</p>
<p>getter (custom getter method name)<br>setter (custom setter method name)</p>
<p>readwrite (default)<br>readonly</p>
<h4 id="weak属性需要在dealloc中置nil么？">weak属性需要在dealloc中置nil么？</h4>
<p>不需要，runtime会在weak属性在释放的时候，自动把变量至为 nil;</p>
<h4 id="@synthesize和@dynamic分别有什么作用？">@synthesize和@dynamic分别有什么作用？</h4>
<p>@synthesize 自动生成属性 getter 和 setter 方法.<br>LLVM Compiler 4.0之后，编译器会对@property 属性自动的添加 @synthesize ivar = _ivar,自动帮你生成 getter/setter 方法，以及自动绑定_ivar 实例变量。</p>
<p>@dynamic 是为了告诉编译器，getter/setter 方法将会在其他地方（父类，runtime）实现，这样可以消除warnnig</p>
<h4 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h4>
<p>atomic, assign, readwrite</p>
<h4 id="用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h4>
<p><a href="http://cp0000.github.io/2015/07/19/nsstring-property-copy-or-retain/" target="_blank" rel="external">NSString Property:copy or retain</a></p>
<h4 id="@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？">@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h4>
<p>首先 complier 会根据 @interface 中的 @property 属性自动生成一份属性名前加<code>_</code>的实例变量。LLVM Compiler 4.0 之后，会自动添加@synthesize ivar = _ivar。</p>
<p>自定义的实例变量 _foo 会和 foo 会自动合成。</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> foo;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>
{
    <span class="built_in">NSInteger</span> _foo;
}

- (<span class="keyword">void</span>)viewDidLoad {
    [<span class="keyword">super</span> viewDidLoad];
    _foo = <span class="number">90</span>;
    <span class="built_in">NSLog</span>(<span class="string">@"self.foo: %ld"</span>, (<span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.foo</span>); <span class="comment">//self.foo: 90</span>
}
</code></pre><p>然后还有一个现象：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> foo;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>
{
    <span class="built_in">NSInteger</span> foo;
}
</code></pre><p>complier 会报 warning : Autosynthesized property ‘foo’ will use synthesized instance variable ‘_foo’, not existing instance variable ‘foo’</p>
<h4 id="在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？">在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h4>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> foo;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>
{
    <span class="built_in">NSInteger</span> _foo3;

}
<span class="keyword">@synthesize</span> foo = _foo3;
</code></pre><p>这样 .m 中就可以 _foo3, 开放给外部的接口 foo，可以隐藏实例变量的名称。</p>
<h4 id="objc中向一个nil对象发送消息将会发生什么？">objc中向一个nil对象发送消息将会发生什么？</h4>
<ul>
<li>nil is basically a null pointer (i.e it is the number zero stored in a pointer).</li>
<li>All messages to nil are legal (they won’t cause a  crash), but they dont’t do anything.</li>
<li>All messages to nil return nil, or 0, or 0.0, or NO, depending on the return type.</li>
</ul>
<h4 id="objc中向一个对象发送消息[obj_foo]和objc_msgSend()函数之间有什么关系？">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h4>
<p>简单来讲 compiler 会把 [receiver message] 转换成 objc_msgSend(receiver, selector, arg1, arg2, …)</p>
<h4 id="什么时候会报unrecognized_selector的异常？">什么时候会报unrecognized selector的异常？</h4>
<ul>
<li>the object’s class, the object’s superclass, the root class, all of them are not implement the called message.</li>
<li>the reveiver has been released</li>
</ul>
<h4 id="一个objc对象如何进行内存布局？（考虑有父类的情况）">一个objc对象如何进行内存布局？（考虑有父类的情况）</h4>
<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中</li>
<li>每一个对象内部都有一个isa指针，指向他的类对象，类对象中存放着本对象的 1）对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）<br>2）成员变量的列表<br>3）属性列表</li>
</ul>
<h4 id="一个objc对象的isa的指针指向什么？有什么作用？">一个objc对象的isa的指针指向什么？有什么作用？</h4>
<p>每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例特点，包括成员变量的列表，成员函数的列表等。<br>所有元类的 isa 指针都会指向一个根元类（root <code>metaclass</code>）.</p>
<h4 id="下面的代码输出什么？">下面的代码输出什么？</h4>
<pre><code><span class="variable">@implementation</span> <span class="constant">Son</span> <span class="symbol">:</span> <span class="constant">Father</span>
- (id)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        <span class="constant">NSLog</span>(@<span class="string">"%@"</span>, <span class="constant">NSStringFromClass</span>([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>]));</span>
        <span class="constant">NSLog</span>(@<span class="string">"%@"</span>, <span class="constant">NSStringFromClass</span>([<span class="keyword">super</span> <span class="class"><span class="keyword">class</span>]));</span>
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="variable">@end</span>
</code></pre><p>都是 Son  </p>
<p>调用[self class]，会转换成 id objc_msgSend(id self, SEL op, …)， 在使用 objc_msgSend 时，第一个参数是 Son 当前的这个实例。第二个参数， 先从 Son 类中找 - (Class) class，没找到， 去父类 Father 中找，也没有，再去 Father 的父类 NSObject 中去找，在 NSObject 的类中发现这个 class 方法， 而 NSObject 的 - (Class) class 的实现就是返回 self 的类别，所以上述结果为 Son</p>
<p>objc runtime 开源代码对 - (Class) class 方法的实现</p>
<pre><code>- (<span class="constant">Class</span>) <span class="class"><span class="keyword">class</span> {</span>
    <span class="keyword">return</span> object_getClass (<span class="keyword">self</span>);
}
</code></pre><p>当调用 [super class],会转换成 objc_msgSendSuper 函数。</p>
<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, <span class="keyword">...</span>)
</code></pre><p>其中 objc_super 的结构体为</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>{
   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
};
</code></pre><p>第一步：构造 objc_super 结构体的时候， 结构体第一个成员变量是 self， 第二个成员变量是 (id) class_getSuperclass(objc_getClass(“Son”)), 函数输出结果是为 Father。<br>第二步：去 Father 这个类里找 - (Class) class, 最后一层层在  NSObject 类中找到。最后内部使用 objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用， 此时已经和 [self class] 调用相同了。</p>
<h4 id="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）">runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h4>
<p>NSObject.h</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">IMP</span>)</span>methodForSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector</span>
</code></pre><p>objc-class.m </p>
<pre><code>IMP class_getMethodImplementation(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>, <span class="title">SEL</span> <span class="title">sel</span>)</span>
</code></pre><p>每一个类对象中管理者一个methodlist,方法列表中记录着方法的名称,方法实现,以及参数类型.</p>
<h4 id="使用runtime_Associate方法关联的对象，需要在主对象dealloc的时候释放么？">使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h4>
<p>无论在MRC下还是ARC下均不需要</p>
<p>对象的内存销毁时间表，分四个步骤</p>
<pre><code>1. 调用 -release ：引用计数变为零
    <span class="keyword">*</span> 对象正在被销毁，生命周期即将结束.
    <span class="keyword">*</span> 不能再有新的 __weak 弱引用， 否则将指向 nil.
    <span class="keyword">*</span> 调用 [self dealloc] 
2. 父类 调用 -dealloc
    <span class="keyword">*</span> 继承关系中最底层的父类 在调用 -dealloc
    <span class="keyword">*</span> 如果是 MRC 代码 则会手动释放实例变量们（iVars）
    <span class="keyword">*</span> 继承关系中每一层的父类 都在调用 -dealloc
3. NSObject 调 -dealloc
    <span class="keyword">*</span> 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
4. 调用 object_dispose()
    <span class="keyword">*</span> 为 C++ 的实例变量们（iVars）调用 destructors 
    <span class="keyword">*</span> 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
    <span class="keyword">*</span> 解除所有使用 runtime Associate方法关联的对象
    <span class="keyword">*</span> 解除所有 __weak 引用
    <span class="keyword">*</span> 调用 free()
</code></pre><h4 id="objc中的类方法和实例方法有什么本质区别和联系？">objc中的类方法和实例方法有什么本质区别和联系？</h4>
<p>类方法：</p>
<ul>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ul>
<p>实例方法：</p>
<ul>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ul>
<h4 id="_objc_msgForward函数是做什么的，直接调用它将会发生什么？">_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h4>
<h4 id="runtime如何实现weak变量的自动置nil？">runtime如何实现weak变量的自动置nil？</h4>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象地址作为 key，当此对象的引用计数为0的时候会 dealloc.假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
<h4 id="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？">能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h4>
<ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
</ul>
<p>解释下：</p>
<p>＋ 编译后的类已经注册在runtime中，类结构体中的 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定，同时 runtime 会调用 class_setIvarLayout 或 class_setWeakivarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>
<ul>
<li>运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。</li>
</ul>
<h4 id="runloop和线程有什么关系？">runloop和线程有什么关系？</h4>
<p>首先 runloop 是一直运行着的循环。run loops 是线程的基础架构部分。每个线程都有与之相对应的 runloop 对象。</p>
<ul>
<li>主线的的runloop默认是开启的</li>
<li>其他线程的runloop是默认没有开启的</li>
</ul>
<h4 id="runloop的mode作用是什么？">runloop的mode作用是什么？</h4>
<p>model 主要是用来指定时间在运行循环中的优先级的<br>苹果公开提供的 Mode 有两个：<br>kCFRunLoopDefaultMode<br>kCFRunLoopCommonModes</p>
<h4 id="以+_scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？">以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h4>
<p>Runloop 只能运行在一种model 下，如果要换mode，当前的runloop也需要停下来重启成新的。利用这个机制，Scrollview滚动过程中NSDefaultRUnllopMode(kCFRunLoopDefaultMode)的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunloopMode模式下处理的事件会影响scrollview的滑动。</p>
<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode(kCFRunLoopDefaultMode)添加到主运行循环中的时候，ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。同时因为mode还是可定制的，所以：Timer 计时会被scrollview的滑动影响的问题可以通过将timer添加到NSRunLoppCommonModes(kCFRunLoopCommonModes)来解决。</p>
<pre><code><span class="comment">//将timer添加到NSDefaultRunLoopMode中</span>
[NSTimer scheduledTimerWithTimeInterval:<span class="number">1.0</span>
     target:<span class="keyword">self</span>
     selector:<span class="keyword">@selector</span>(timerTick:)
     userInfo:<span class="literal">nil</span>
     repeats:<span class="literal">YES</span>];
<span class="comment">//然后再添加到NSRunLoopCommonModes里</span>
NSTimer *timer = [NSTimer timerWithTimeInterval:<span class="number">1.0</span>
     target:<span class="keyword">self</span>
     selector:<span class="keyword">@selector</span>(timerTick:)
     userInfo:<span class="literal">nil</span>
     repeats:<span class="literal">YES</span>];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre><h4 id="猜想runloop内部是如何实现的？">猜想runloop内部是如何实现的？</h4>
<pre><code><span class="title">while</span> (date &lt; untileDate) {
    <span class="title">id</span> event = listenEvent (); 
    <span class="title">handleEvent</span> (v);
}
</code></pre><h4 id="objc使用什么机制管理对象内存？">objc使用什么机制管理对象内存？</h4>
<p>通过 retainCount 的机制来决定对象是否需要释放每次 runloop 的时候，都会检查对象的retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>
<h4 id="ARC通过什么方式帮助开发者管理内存？">ARC通过什么方式帮助开发者管理内存？</h4>
<p>编译时根据代码上下文，插入 retain/release </p>
<h4 id="不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）">不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h4>
<p>在每次 eventloop 开始创建自动创建释放池， 在每次事件结束销毁自动释放池。<br>以 viewDidLoad 方法为例，在viewDidLoad方法开始执行之前创建自动释放池,在viewDidAppear方法执行之后销毁自动释放池。</p>
<h4 id="BAD_ACCESS在什么情况下出现？">BAD_ACCESS在什么情况下出现？</h4>
<ul>
<li>访问了野指针</li>
<li>死循环</li>
</ul>
<h4 id="苹果是如何实现autoreleasepool的？">苹果是如何实现autoreleasepool的？</h4>
<p>autoreleasepool以一个队列数组的形式实现，主要通过下列三个函数完成.</p>
<ul>
<li>objc_autoreleasepoolPush</li>
<li>objc_autoreleasepoolPop</li>
<li>objc_autorelease</li>
</ul>
<p>对autorelease分别执行push，和pop操作。销毁对象时执行release操作。</p>
<h4 id="使用block时什么情况会发生引用循环，如何解决？">使用block时什么情况会发生引用循环，如何解决？</h4>
<p>一个对象对 block 进行了强引用，而在 block 内部有直接使用到该对象。</p>
<p>声明一个 weak 的对象指向该对象， 在 block 内部使用该 weak 对象。</p>
<pre><code><span class="keyword">id</span> <span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>; 或者 <span class="keyword">weak</span> __<span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>该方法可以设置宏
<span class="keyword">id</span> __block weakSelf = <span class="keyword">self</span>;
</code></pre><h4 id="在block内如何修改block外部变量？">在block内如何修改block外部变量？</h4>
<p>默认情况下，在block中访问的外部变量时复制过去的，既：写操作不对原变量生效。但是可以通过加上__block修饰外部变量。</p>
<pre><code>__block <span class="keyword">int</span> a = <span class="number">0</span>;
<span class="keyword">void</span>  (^foo)(<span class="keyword">void</span>) = ^{ 
    a = <span class="number">1</span>; 
}
f00();
</code></pre><p>实现原理，简单来讲，外部变量通过指针传递，将变量传递到 block 内，所以可以修改变量值。</p>
<h4 id="使用系统的某些block_api（如UIView的block版本写动画时），是否也考虑引用循环问题？">使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h4>
<p>NO, since self will be captured in the block which is dispatched asynchronously, self will be implicity retained, and released again when the block has been finished.</p>
<p>That means, the life-time of self will be extended  up until after the block finishes.</p>
<h4 id="GCD的队列（dispatch_queue_t）分哪两种类型？">GCD的队列（dispatch_queue_t）分哪两种类型？</h4>
<ul>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ul>
<h4 id="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）">如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h4>
<p>使用 Dispatch Group 追加block到Global Group Queue，这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block</p>
<pre><code>dispatch_queue_t <span class="built_in">queue</span> <span class="subst">=</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);
dispatch_group_t <span class="keyword">group</span> <span class="subst">=</span> dispatch_group_create();
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{ <span class="comment">/*加载图片1 */</span> });
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{ <span class="comment">/*加载图片2 */</span> });
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{ <span class="comment">/*加载图片3 */</span> }); 
dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^{
        <span class="comment">// 合并图片</span>
});
</code></pre><h4 id="dispatch_barrier_async的作用是什么？">dispatch_barrier_async的作用是什么？</h4>
<p>在并行队列中，为了保持某些任务的顺序，需要等待一些人物完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async<br>追加的处理执行结束之后，Concurrent Dispatch Queue 才恢复之前的动作继续执行。</p>
<pre><code><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"test_queue"</span>, DISPATCH_QUEUE_CONCURRENT);  
<span class="built_in">dispatch_async</span>(queue, ^{  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_async1"</span>);  
});  
<span class="built_in">dispatch_async</span>(queue, ^{  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4</span>];  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_async2"</span>);  
});  
dispatch_barrier_async(queue, ^{  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_barrier_async"</span>);  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4</span>];  

});  
<span class="built_in">dispatch_async</span>(queue, ^{  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_async3"</span>);  
}); 
</code></pre><h4 id="苹果为什么要废弃dispatch_get_current_queue？">苹果为什么要废弃dispatch_get_current_queue？</h4>
<p>dispatch_get_current_queue容易造成死锁</p>
<h4 id="以下代码运行结果如何？">以下代码运行结果如何？</h4>
<pre><code>- (void)viewDidLoad
{
    <span class="attr_selector">[super viewDidLoad]</span>;
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"1"</span>);</span>
    <span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"2"</span>);</span>
    });
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"3"</span>);</span>
}
</code></pre><p>只输出：1 。发生主线程锁死。原因是主队列在等待 dispatch_sync(dispatch_get_main_queue(), ^{NSLog(@”2”);});执行。dispatch_sync 在等待著队列执行完毕，造成死锁。</p>
<h4 id="addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？">addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h4>
<pre><code><span class="comment">// 添加键值观察</span>
<span class="comment">/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
*/</span>
[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:@<span class="string">"name"</span> options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@<span class="string">"Person Name"</span>];
</code></pre><p>observer中需要实现以下方法：</p>
<pre><code><span class="comment">// 所有的 kvo 监听到事件，都会调用此方法</span>
<span class="comment">/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */</span>
- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context;
</code></pre><h4 id="如何手动触发一个value的KVO">如何手动触发一个value的KVO</h4>
<p>所谓的“手动触发”是区别于”自动触发：<br>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。想知道如何手动触发，就得搞明白自动触发 KVO 的原理：</p>
<p>键值观察通知依赖于 NSObject 的两个方法： willChangeValueForKey: 和 didChangeValueForKey:。在一个被观察属性发生改变之前，willChangeValueForKey:一定会被调用，这就会记录旧的值。而当改变发生之后，didChangeValueForKey:会被调用，继而observeValueForKey:ofObject:change:context也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了；</p>
<p>那么”手动触发“的使用场景是什么？一般我们只在希望能控制”回调的调用时机”时才会这么做。</p>
<p>具体做法如下：</p>
<p>如果这个value是表示时间的 self.now,那么代码如下：</p>
<pre><code><span class="comment">//@property (nonatomic, strong) NSDate *now;</span>
- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];
    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"now"</span>]; <span class="comment">// “手动触发self.now的KVO”，必写。</span>
    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"now"</span>]; <span class="comment">// “手动触发self.now的KVO”，必写。</span>
}
</code></pre><p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>
<p>比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。</p>
<h4 id="若一个类有实例变量NSString_*_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？">若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h4>
<p>Both</p>
<h4 id="KVC的keyPath中的集合运算符如何使用？">KVC的keyPath中的集合运算符如何使用？</h4>
<ul>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有 @avg, @count, @max, @min, @sum</li>
<li>格式 @”sum.age”或@”集合属性.@max.age”</li>
</ul>
<h4 id="KVC和KVO的keyPath一定是属性么？">KVC和KVO的keyPath一定是属性么？</h4>
<p>KVO支持实例变量</p>
<h4 id="如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？">如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h4>
<h4 id="apple用什么方式实现对一个对象的KVO？">apple用什么方式实现对一个对象的KVO？</h4>
<p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的setter方法。重写setter方法会负责在调用原setter方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写 （isa-swizzling）把这个对象的 isa 指针（isa指针告诉Runtime系统这个对象的类是什么）指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。</p>
<p>详细解释：</p>
<p>键值观察者通知依赖于NSObject的两个方法： willChangeValueForKey: and didChangeValueForKey: 。在一个被观察属性发生改变之前, willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当发生改变之后，didChangeValueForKey:会被调用，继而observerValueForKey:ofObject:change:context:也会被调用。可以手动实现这些调用，但很少这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>
<h4 id="IBOutlet连出来的视图属性为什么可以被设置成weak?">IBOutlet连出来的视图属性为什么可以被设置成weak?</h4>
<p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了</p>
<h4 id="IB中User_Defined_Runtime_Attributes如何使用？">IB中User Defined Runtime Attributes如何使用？</h4>
<p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>
<h4 id="如何调试BAD_ACCESS错误">如何调试BAD_ACCESS错误</h4>
<ul>
<li>From the Scheme toolbar menu, choose a scheme.</li>
<li>From the same menu, choose Edit Scheme to display the scheme dialog</li>
<li>In the left column, select run</li>
<li>To specify runtime diagnostics,click the Diagnostics tab.</li>
<li>For debug BAD_ACCESS, enable the Enable Zombie Objects checkbox.</li>
<li>Click Close</li>
<li>Click the Run button or chosse Product &gt; Run</li>
</ul>
<h4 id="lldb（gdb）常用的调试命令？">lldb（gdb）常用的调试命令？</h4>
<p><code>po</code> <code>expression</code> <code>call</code> <code>thread return &lt;RETURN EXPRESSION&gt;</code> <code>b</code> <code>thread backtrace</code></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-07-19T03:50:04.000Z"><a href="/2015/07/19/nsstring-property-copy-or-retain/">Jul 19 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/19/nsstring-property-copy-or-retain/">从 NSString Property:copy or retain 到 NSCopying</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="NSString_Property:copy_or_retain">NSString Property:copy or retain</h4>
<p>iOS程序中，在定义对象属性的时候，我们一般会把<code>NSString</code>类型的属性的修饰符写成 <code>copy</code>， 而不是 <code>retain</code> (或者 ARC 下面的 <code>strong</code>)。</p>
<p><strong>为什么会有<code>NSString</code>要用<code>copy</code>来修饰的convention？能否用 <code>strong</code>代替?</strong></p>
<p>回答这个问题之前，我们先看段代码：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">Fruit</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)     <span class="built_in">NSString</span>  * fruitNameCopy;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)   <span class="built_in">NSString</span>  * fruitNameStrong;
<span class="keyword">@end</span>

<span class="built_in">NSMutableString</span> * fruitName = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"apple"</span>];

Fruit * fruit = [[Fruit alloc] init];
fruit<span class="variable">.fruitNameCopy</span>     = fruitName;
fruit<span class="variable">.fruitNameStrong</span>   = fruitName;

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName); <span class="comment">// 0x7fddabd0e250  apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>); <span class="comment">// 0xa0000656c7070615 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>); <span class="comment">// 0x7fddabd0e250  apple</span>

<span class="comment">//fruitName =@"pear";</span>
[fruitName setString: <span class="string">@"pear"</span>];

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName); <span class="comment">// 0x7fddabd0e250  pear</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>); <span class="comment">// 0xa0000656c7070615 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>); <span class="comment">// 0x7fddabd0e250  pear</span>
</code></pre><p>该段程序运行到结尾时， fruitNameCopy 的值是 apple，fruitNameCopy 的值是 pear，且两者的内存地址也不一样。<br>程序中，当我们对一个mutable对象做<code>copy</code>操作的时候，objc runtime 会用一次<a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="external">深拷贝</a>来处理， runtime 会重新分配一块内存地址空间，并把原mutable对象的值拷贝过来。所以打印出来的 fruitNameCopy 和 fruitNameStrong 的内存地址是不一样的。而这之后在对 fruitName 做任何的赋值操作都只能作用于 fruitNameStrong.</p>
<p><strong>那如果我们把 fruitName 改成 immutable 的会是怎样的了？</strong></p>
<pre><code><span class="built_in">NSString</span> * fruitName = <span class="string">@"apple"</span>;

Fruit * fruit = [[Fruit alloc] init];
fruit<span class="variable">.fruitNameCopy</span>     = fruitName;
fruit<span class="variable">.fruitNameStrong</span>   = fruitName;

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName);<span class="comment">// 0x10e27b078 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>);<span class="comment">// 0x10e27b078 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>);<span class="comment">// 0x10e27b078 apple</span>

fruitName =<span class="string">@"pear"</span>;

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName);<span class="comment">// 0x10e27b0f8 pear</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>);<span class="comment">// 0x10e27b078 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>);<span class="comment">// 0x10e27b078 apple</span>
</code></pre><p>结果是 fruitName, fruitNameCopy, fruitNameStrong 三者的地址都是一样的。按理说<code>copy</code>动作是深拷贝，fruitNameCopy指向的地址 应该是新分配的内存地址才对。<br>那为什么打印出来的地址却是同一个地址了？答案是 runtime 在这里做一个性能优化，@”apple” 是一个immutable的值，没有必要做一次深拷贝，直接做一次 retain 就达到目的了。</p>
<p><strong>试试看把<code>NSString</code>替换成<code>NSArray</code></strong></p>
<p>对象 Fruit 中添加两个属性<br>    @property (nonatomic, copy)     NSArray  <em> placesCopy;<br>    @property (nonatomic, strong)   NSArray  </em> placesStrong;</p>
<p>先用 mutable 的变量试试</p>
<pre><code><span class="built_in">NSMutableArray</span> * places = [<span class="built_in">NSMutableArray</span> arrayWithArray:@[<span class="string">@"china"</span>, <span class="string">@"japan"</span>]];
fruit<span class="variable">.placesCopy</span>    = places; <span class="comment">//placesCopy: 0x7f8f18d0c4f0 (china,japan)</span>
fruit<span class="variable">.placesStrong</span>  = places; <span class="comment">//placesStrong: 0x7f8f18d51a80 (china,japan)</span>

[places addObject:<span class="string">@"korea"</span>];
<span class="comment">//placesCopy: 0x7f8f18d0c4f0 (china,japan)</span>
<span class="comment">//placesStrong: 0x7f8f18d51a80 (china,japan, korea)</span>
</code></pre><p>再用 immutable 的变量试试</p>
<pre><code><span class="constant">NSArray * places</span> = @[@<span class="string">"china"</span>, @<span class="string">"japan"</span>];

fruit.placesCopy    = places; <span class="comment">//placesCopy: 0x7fc4e8c6f2a0 (china,japan)</span>
fruit.placesStrong  = places; <span class="comment">//placesStrong: 0x7fc4e8c6f2a0 (china,japan)</span>

places = @[@<span class="string">"uk"</span>, @<span class="string">"us"</span>];
<span class="comment">//placesCopy: 0x7fc4e8c6f2a0 (china,japan)</span>
<span class="comment">//placesStrong: 0x7fc4e8c6f2a0 (china,japan)</span>
</code></pre><p>实验结果和 <code>NSString</code> 是一致的。</p>
<h4 id="NSCopying">NSCopying</h4>
<p>如果你愿意，你可以试试看其他容器类 <code>NSDictionary</code>, <code>NSSet</code>,<code>NSIndexSet</code>， 会发现结果也保持一致。我们尝试解读这些类的头文件，作进一步的探索。以下是这些类头文件的节选：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSFastEnumeration</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span>&lt;<span class="title">__covariant</span> <span class="title">KeyType</span>, <span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSFastEnumeration</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSSet</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSFastEnumeration</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSIndexSet</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSIndexPath</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span>
</code></pre><p>会发现这些类都实现了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSCopying_Protocol/index.html" target="_blank" rel="external"><code>NSCoying</code></a>协议.在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSCopying_Protocol/index.html" target="_blank" rel="external"><code>NSCoying</code></a>文档中有关于实现该协议的三条准则，其中第三条是：</p>
<pre><code>Implement NSCopying <span class="keyword">by</span> retaining <span class="operator">the</span> original instead <span class="operator">of</span> creating <span class="operator">a</span> <span class="built_in">new</span> copy when <span class="operator">the</span> class <span class="operator">and</span> its contents are immutable.
</code></pre><p>这条准则很好的解释了上面的试验结果，让这些结果讲得通。</p>
<h4 id="Summary">Summary</h4>
<p><strong>综上，当我们使用<code>copy</code>来修饰<code>NSString</code>等容器类的属性时，如果被拷贝的对象是 Mutable， 则 runtime 会做深拷贝， 如果是 Immutable， 则runtime只是做一次 <code>retain</code>。</strong></p>
<p><strong>如果在程序中我们自己定义的类也需要实现 <code>NSCopying</code> 协议时，务必也要遵照此规则：若被拷贝的原对象是 Immutable 的，则无需新建一个拷贝，只需要 retian 原对象一次；若原对象是 mutablde 的，则需做一次深拷贝，新建一个对象</strong></p>
<p><strong>如果在程序中，你需要避免一个对象的某个属性被反向更改 (prevent mutating an object’s attributes behind its back)，请把该属性标记成 <code>copy</code></strong></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2014-05-20T16:00:00.000Z"><a href="/2014/05/21/regular-expression-beginner/">May 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/05/21/regular-expression-beginner/">Regular Expression</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="常用的元字符">常用的元字符</h1>
<table>
<thead>
<tr>
<th style="text-align:left">代码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">*前边的内容可以连续重复使用任意次以使整个表达式得到匹配</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配除了换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:left">匹配一位数字(0，或1，或2，或……)</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">匹配任意的空白符</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配字符串的结束</td>
</tr>
</tbody>
</table>
<h1 id="常用的限定符">常用的限定符</h1>
<table>
<thead>
<tr>
<th style="text-align:left">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">重复零次或更多次</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">重复一次或更多次</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">重复零次或一次</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">重复n次</td>
</tr>
<tr>
<td style="text-align:left">{n,}</td>
<td style="text-align:left">重复n次或更多次</td>
</tr>
<tr>
<td style="text-align:left">{n,m}</td>
<td style="text-align:left">重复n次到m次</td>
</tr>
</tbody>
</table>
<h1 id="其他">其他</h1>
<ul>
<li><strong>字符转义</strong></li>
</ul>
<p>如需查找*,+等元字符本身的话，需使用\来取消这些字符的特殊含义；</p>
<pre><code><span class="command">\.</span> <span class="command">\*</span>
</code></pre><ul>
<li><strong>字符类</strong></li>
</ul>
<p>匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),只需在方括号里列出；如：</p>
<pre><code>[<span class="link_reference">aeiou</span>]:<span class="link_url">    匹配任何一个英文元音字母；</span><span class="link_url">
[.?!]:        匹配标点符号(.或?或!)</span>
</code></pre><p>(?0\d{2}[) -]?\d{8}：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})</p>
<ul>
<li><strong>分枝条件</strong></li>
</ul>
<p>分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开</p>
<ul>
<li><strong>分组</strong></li>
</ul>
<p>用小括号来指定子表达式(也叫做分组）</p>
<p>e.g. IP地址匹配:  (\d{1,3}.){3}\d{1,3}<br>解析：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})</p>
<ul>
<li><strong>反义</strong></li>
</ul>
<p>常用的反义代码</p>
<table>
<thead>
<tr>
<th style="text-align:left">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\W</td>
<td style="text-align:left">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td style="text-align:left">\D</td>
<td style="text-align:left">匹配任意非数字的字符</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td style="text-align:left">[^x]</td>
<td style="text-align:left">匹配除了x以外的任意字符</td>
</tr>
<tr>
<td style="text-align:left">[^aeiou]</td>
<td style="text-align:left">匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>后向引用</strong></p>
<p>  …</p>
</li>
<li><p><strong>零宽断言</strong></p>
<p>  …</p>
</li>
</ul>
<ul>
<li><p><strong>负向零宽断言</strong></p>
<p>  …</p>
</li>
<li><p><strong>注释</strong></p>
<p>  …</p>
</li>
<li><p><strong>贪婪与懒惰</strong></p>
<p>  …</p>
</li>
<li><p><strong>处理选项</strong></p>
<p>  …</p>
</li>
</ul>
<ul>
<li><p><strong>平衡组/递归匹配</strong></p>
<p>  …</p>
</li>
</ul>
<h1 id="Example">Example</h1>
<table>
<thead>
<tr>
<th>RE</th>
<th>示意</th>
</tr>
</thead>
<tbody>
<tr>
<td>\bhi\b</td>
<td>查找单词hi</td>
</tr>
<tr>
<td>.*</td>
<td>任意数量的不包含换行的字符</td>
</tr>
<tr>
<td>\bhi\b.*\bLucy\b</td>
<td>先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词</td>
</tr>
<tr>
<td>0\d{2}-\d{8}</td>
<td>\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)</td>
</tr>
<tr>
<td>c.d(.+)</td>
<td>查询到结果类似于c.d((c)a, string)</td>
</tr>
<tr>
<td>((2[0-4]\d</td>
<td>25[0-5]</td>
<td>[01]?\d\d?).){3}(2[0-4]\d</td>
<td>25[0-5]</td>
<td>[01]?\d\d?)</td>
<td>IP地址</td>
</tr>
</tbody>
</table>
<h1 id="附录：">附录：</h1>
<p>更多信息，请阅读：<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">https://deerchao.net/tutorials/regex/regex.htm</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2014-04-09T16:00:00.000Z"><a href="/2014/04/10/google-wildcard/">Apr 10 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/10/google-wildcard/">Google Wildcard</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.双引号</p>
<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</p>
<pre><code>“seo方法图片”
</code></pre><p>2.减号</p>
<p>减号代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。</p>
<pre><code>搜索 -引擎
</code></pre><p>3.星号</p>
<p>星号常用的通配符</p>
<pre><code>搜索<span class="keyword">*</span>擎
</code></pre><p>4.inurl</p>
<p>inurl: 指令用于搜索查询词出现在url 中的页面。</p>
<pre><code>inur<span class="variable">l:</span>搜索引擎优化
</code></pre><p>5.inanchor</p>
<p>指令返回的结果是导入链接锚文字中包含搜索词的页面。</p>
<pre><code><span class="label">inanchor:</span>点击这里
</code></pre><p>6.intitle</p>
<p>指令返回的是页面title 中包含关键词的页面。</p>
<p>7.allintitle</p>
<p>搜索返回的是页面标题中包含多组关键词的文件。</p>
<p>8.filetype</p>
<p>用于搜索特定文件格式。</p>
<pre><code><span class="tag">filetype</span><span class="pseudo">:pdf</span> <span class="tag">SEO</span>
</code></pre><p>9.site</p>
<p>用来搜索某个域名下的所有文件。</p>
<pre><code><span class="tag">site</span><span class="pseudo">:developer</span><span class="class">.apple</span><span class="class">.com</span> <span class="tag">gcd</span>
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2014-02-28T16:00:00.000Z"><a href="/2014/03/01/android-reverse-engineering/">Mar 1 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/01/android-reverse-engineering/">Android reverse engineering</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="名词解释">名词解释</h4>
<ul>
<li>java: android app 编程语言</li>
<li>class: 由 java文件通过 Sun JDK 编译而成</li>
<li><p>dex:  Dex文件的指令码是Dalvik虚拟机专有的一套指令集，专门为嵌入式系统优化过，相比标准java的.class文件，它体积小，运行效率高。</p>
<p>  ps:通过Android平台上的工具(dx)将.class文件 转换成Dex字节码（classes.dex）</p>
</li>
<li><p>odex: 在原生Android中安装apk会产生apk 和 odex 两个文件，而使用第三方的rom只有apk一个文件；odex 是同名apk经系统优化后的dex文件，原生ROM中apk和odex文件是配对的，对应的apk文件中没有了dex文件。</p>
</li>
<li><p>smali, baksmali:分别指android系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器</p>
<p>  ps: Smali文件是dalvik虚拟机运行的dex字节码文件对应的汇编文件。</p>
</li>
<li><p>Andoid App 的运行策略：解压apk后运行class.dex</p>
</li>
</ul>
<h4 id="工具介绍">工具介绍</h4>
<ul>
<li>ant: 编译，生成android 项目的工具；</li>
<li>apktool： 用来解压 apk，虽说apk实际是一个压缩包，可以用unzip直接解压，不过apktool还是做了更多的优化，如直接reverse androidmanifest.xml</li>
<li>smali-2.0.3.jar: 把smali 文件转换成 dex文件</li>
<li>baksmali-2.0.2.jar: 把dex文件转换成smali文件</li>
<li>dex2jar: dex 转换成 jar</li>
<li>signapk.jar: 用来签名apk</li>
<li>eclipse: 大多数android项目的IDE</li>
<li>adb: android debug bridge;可用来 adb logcat 打印错误日志； adb push 来更新项目存在/data/data中的文件；</li>
<li>JD-GUi:图形界面的Java源代码”.class”文件反编译工具</li>
</ul>
<h4 id="DEMO演示">DEMO演示</h4>
<ul>
<li>首先我们需要一个 apk，我去到豌豆荚网页版下载一个名叫［百度］的apk；</li>
<li>使用 adb install baidu.apk到 手机，先把玩一下这个app的主要功能；差不多就是一个网页版的apk；</li>
<li><p>然后开始对这个apk动手脚；</p>
<pre><code>  apktool d baidu.apk /<span class="keyword">*</span> 反编译apk <span class="keyword">*</span>/
</code></pre><p>会发现在当前的目录下生成一个baidu 的 folder：</p>
<pre><code>  <span class="tag">staff</span>  48732 <span class="tag">Mar</span>  1 19<span class="pseudo">:26</span> <span class="tag">AndroidManifest</span><span class="class">.xml</span>
  <span class="tag">staff</span>    250 <span class="tag">Mar</span>  1 19<span class="pseudo">:26</span> <span class="tag">apktool</span><span class="class">.yml</span>
  <span class="tag">staff</span>    408 <span class="tag">Mar</span>  1 19<span class="pseudo">:26</span> <span class="tag">assets</span>
  <span class="tag">staff</span>    102 <span class="tag">Mar</span>  1 20<span class="pseudo">:08</span> <span class="tag">build</span>
  <span class="tag">staff</span>    102 <span class="tag">Mar</span>  1 20<span class="pseudo">:08</span> <span class="tag">dist</span>
  <span class="tag">staff</span>    102 <span class="tag">Mar</span>  1 19<span class="pseudo">:26</span> <span class="tag">lib</span>
  <span class="tag">staff</span>    884 <span class="tag">Mar</span>  1 19<span class="pseudo">:26</span> <span class="tag">res</span>
  <span class="tag">staff</span>    170 <span class="tag">Mar</span>  1 19<span class="pseudo">:26</span> <span class="tag">smali</span>
</code></pre></li>
</ul>
<p>这是baidu  android project的目录结构，有了上面的名词解释，我们知道 代码逻辑都存在了smali这个文件夹下；不过smali有点不好阅读，所以我建议大家还是把smali 翻译成java之后在去阅读 baidu.apk 的源代码；</p>
<p>我的方法是:unzip apk得到 classes.dex，然后利用dex2jar 得到clases_dex2jar.jar;然后使用JD-GUi打开jar 文件就可以非常愉快的阅读java 代码了；</p>
<pre><code>    unzip baidu.apk <span class="operator">-d</span> baidu_deout;
    dex2jar.sh baidu_deout/classes.dex
</code></pre><p>由于是Demo，所以我展示一个简单的hack好了；打开BaseActivity.java 会发现</p>
<pre><code><span class="keyword">if</span> (b)
  <span class="built_in">Log</span>.d(<span class="string">"SearchBox"</span>, <span class="string">"=========BaseActivity onStop mLiveActivityNum="</span> + o);
</code></pre><p>很明显 b是类似 debug_mode 的开关变量，如果你之前在运行baidu.apk的时候adb logcat 一下，留心一下是没有这个log的，所以在release android.apk 的时候，debug_mode 理应被set成false了；所以我现在想做的事情就是打开debug_mode;因为debug log这种的东西有太多的惊喜；</p>
<p>接下来的事情就变得非常简单找到 set  debugmode 的位置，设置成true就好了；顺藤摸瓜；在BaseActivity.java  的开头，会发现：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> b = SearchBox.a;
</code></pre><p>而SearchBox.java 的第一行：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> a = dk.a;
</code></pre><p>db.java 的第一行：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> a = <span class="keyword">false</span>;
</code></pre><p>事情不能更顺利了，所以只要把 a 的值set 成true就完成打开debugmode的小hack了；</p>
<p>还记得之前apktool 反编译的文件夹嘛？打开db.smali 文件；会发现：</p>
<pre><code><span class="keyword">const</span>/<span class="number">4</span> v1, <span class="number">0x0</span>
<span class="keyword">const</span>/<span class="number">4</span> v0, <span class="number">0x1</span>
sput-boolean v1, Lcom/baidu/searchbox/dk;-&gt;a:Z
</code></pre><p>是的，只要修改成</p>
<pre><code>sput-<span class="keyword">boolean</span> v0, Lcom<span class="regexp">/baidu/</span>searchbox<span class="regexp">/dk;-&gt;a:Z</span>
</code></pre><p>就好了；</p>
<p>修改完smali之后，我们需要做的是重新生成一个apk：</p>
<pre><code><span class="title">apktool</span> b baidu
</code></pre><p>会发现在baidu/dist/目录下生成了一个新的baidu.apk; 这时候如果你选择 </p>
<pre><code><span class="title">adb</span> installl －r baidu.apk
</code></pre><p>会发现提示：Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]这是由于这个apk没有sign的原因；接下里sign apk；</p>
<pre><code> java -jar <span class="regexp">/opt/</span>Android<span class="regexp">/signapk/</span>signapk.jar <span class="regexp">/opt/</span>Android<span class="regexp">/signapk/</span>signapk-key.testkey.x509.pem <span class="regexp">/opt/</span>Android<span class="regexp">/signapk/</span>signapk-key.testkey.pk8 CHFR_360.apk CHFR_360-sign.apk
</code></pre><p>执行成功之后，惊喜的发现在 dist 新生成了 baidu-sign.apk,安装到手机，运行apk，打开adb logcat:</p>
<pre><code><span class="type">D</span>/<span class="built_in">c</span>       (<span class="number">17822</span>): statistic key: <span class="number">011918</span>
<span class="type">E</span>/<span class="built_in">c</span>       (<span class="number">17822</span>): 写入行为统计:{<span class="string">"011918"</span>:[<span class="string">""</span>]}
<span class="type">E</span>/<span class="built_in">c</span>       (<span class="number">17822</span>): 写入widget用户行为统计：{<span class="string">"011918"</span>:[<span class="string">""</span>]}
<span class="type">D</span>/<span class="built_in">c</span>       (<span class="number">17822</span>): statistic key: <span class="number">011918</span>
<span class="type">E</span>/<span class="built_in">c</span>       (<span class="number">17822</span>): 写入行为统计:{<span class="string">"011918"</span>:[<span class="string">""</span>]}
<span class="type">E</span>/<span class="built_in">c</span>       (<span class="number">17822</span>): 写入widget用户行为统计：{<span class="string">"011918"</span>:[<span class="string">""</span>]}
</code></pre><p>如果一切正常的话，会发现类似如上的log，当然你仔细看的话，还有更详细且重要的信息，各种的小隐私都被监视…</p>
<p>Android 项目的逆向工程的文章就到这里；<br>Enjoy it!</p>
<h4 id="相关参考：">相关参考：</h4>
<ul>
<li><a href="http://stackoverflow.com/questions/12732882/reverse-engineering-from-an-apk-file-to-a-project" target="_blank" rel="external">http://stackoverflow.com/questions/12732882/reverse-engineering-from-an-apk-file-to-a-project</a></li>
<li><a href="http://stackoverflow.com/questions/13854425/how-to-avoid-reverse-engineering-of-an-apk-file" target="_blank" rel="external">http://stackoverflow.com/questions/13854425/how-to-avoid-reverse-engineering-of-an-apk-file</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  

  <ul class="page-direction" id="page-direction">
    <li><a class="page-prev icon-chevron-sign-left" href="javascript:;" title="Prev"></a></li>
    <li><a class="page-next icon-chevron-sign-right" href="javascript:;" title="Next"></a></li>
</ul>

    <nav id="page-list" class="page-list"><a class="extend prev" rel="prev" href="/categories/Tech/">Prev</a><a class="page-number" href="/categories/Tech/">1</a><span class="page-number current">2</span></nav>

<nav id="pagination">
  
    <a href="/categories/Tech/" class="alignleft prev">Prev</a>
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="text" name="q" results="0" placeholder="Search">
    <i class="icon-search"></i>
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/iOS-Reverse-Engineering/">iOS Reverse Engineering</a><small>3</small></li>
  
    <li><a href="/tags/mac-power-user/">mac power user</a><small>1</small></li>
  
  </ul>
</div>


  <div class="trace-invest">
    <span>
        <a href="http://traceinvest.com" target="_blank">欢迎光临我的美股投资相关网站 :</br>traceinvest.com</a>
    </span>
</div>


  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2017/10/04/opengl-lighting/">Learning OpenGL：光照</a>
      </li>
    
      <li>
        <a href="/2017/08/06/shoe-dog/">读书笔记：《鞋狗》</a>
      </li>
    
      <li>
        <a href="/2017/07/02/Kangrinboqe/">冈仁波齐</a>
      </li>
    
      <li>
        <a href="/2017/03/19/framebuffer-object-opengl/">Learning OpenGL：帧缓冲对象</a>
      </li>
    
      <li>
        <a href="/2017/02/26/GLSL-Dictionary/">Learning OpenGL：GLSL Shader 手册</a>
      </li>
    
      <li>
        <a href="/2017/01/29/becoming-steve-jobs/">读书笔记《成为乔布斯》</a>
      </li>
    
      <li>
        <a href="/2016/12/18/opengl-3d-matrix/">OpenGL ES 2.0 3D基础（1）－矩阵</a>
      </li>
    
      <li>
        <a href="/2016/12/11/2016-summary/">2016年度总结</a>
      </li>
    
      <li>
        <a href="/2016/11/07/ffmpeg-command-example/">ffmpeg 使用例程</a>
      </li>
    
      <li>
        <a href="/2016/10/26/28/">活到28</a>
      </li>
    
      <li>
        <a href="/2016/10/22/install-caffe-on-macosx/">如何在Macosx上安装caffe</a>
      </li>
    
      <li>
        <a href="/2016/09/25/2016-1st-half/">2016上半年电影，美剧，以及书 清单</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <div id="go-pg-top"><i class="icon-arrow-up"></i></div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Pei Cheng
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/page.js"></script>

</body>

</html>