<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CP WRITINGS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="CP WRITINGS">
<meta property="og:url" content="http://cp0000.github.io/page/3/">
<meta property="og:site_name" content="CP WRITINGS">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CP WRITINGS">
<meta name="twitter:description">

  
    <link rel="alternative" href="/atom.xml" title="CP WRITINGS" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CP WRITINGS</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-archives-icon" class="nav-icon" href="/archives"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about/index.html"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Peek-and-pop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/10/25/Peek-and-pop/">3D-Touch(2) PEEK And POP</a>
  

      </header>
    
    <time class="article-date" datetime="2015-10-25T02:36:21.000Z" itemprop="datePublished">10-25-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>如上篇文章所说，3D Touch 主要分成三个模块： Home Actions, Peek &amp; Pop, Force Properties。上篇文章中总结了 Home Actions的相关知识点以及如何接入该功能。本文将用来介绍Peek &amp; Pop 的相关知识点。</p>
<p>在给你的app接入peeking and poping 的功能之前，需要先了解该操作的三个属性， peeking, preview actions, poping。如下图所示：</p>
<p><img src="http://cp0000.github.io/assets/peekandpop.gif" alt="peek_and_pop"></p>
<p>用户在 Peeking 图片，视频，网页等内容的时候，能够在不去加载全部内容的情况下获取到更多详细的内容。</p>
<h2 id="PEEKING">PEEKING</h2>
<p>当用户对某个view做peeking操作时，程序会展现给用户相对应内容的快照。Peek 操作是 3DTouch 中实现起来相对比较复杂的模块。Peek and Pop API 中有一个 <code>UIViewControllerPreviewingDelegate</code>,给指定的view需要注册这个delegate，就可以接收到系统回调过来的3D Touch事件。</p>
<pre><code>override func viewDidLoad() {
    <span class="keyword">super</span>.viewDidLoad()

    /*  
        Register <span class="keyword">for</span> `<span class="javascript">UIViewControllerPreviewingDelegate</span>` to enable
        <span class="string">"Peek"</span> <span class="keyword">and</span> <span class="string">"Pop"</span>.
        The view controller will be automatically unregistered <span class="keyword">when</span> it <span class="keyword">is</span>
        deallocated.
    */
    registerForPreviewingWithDelegate(self, <span class="attribute">sourceView</span>: view)
}
</code></pre><p>这里有一点需要注意，我们可以在一个 view Controller 中，给多个view注册 Previewing Delegate ，但是我们不能反复去注册同一个view。</p>
<blockquote>
<p>“You can designate more than one source view for a single registered view controller, but you cannot designate a single view as a source view more than once.”</p>
</blockquote>
<p>Peek的操作过程可以分解成下面三个步骤：</p>
<p><img src="http://cp0000.github.io/assets/peek_and_pop2.png" alt="peek_and_pop_2"></p>
<p>Peek的系统回调函数会提供一个关于 source view的context，以及 touch事件的point。以sourceView为 collectionView为例，回调函数中我们需要处理以下三件事情：</p>
<ul>
<li>(1) 根据 location 找到被 peeked 的 cell，以及cell的 NSIndexPath</li>
<li>(2) 设置 previewingContext 的 sourceRect 大小</li>
<li>(3) alloc 一个 PreViewController，并设置背景图片，title之类的， 然后返回这个 PreviewController</li>
</ul>
<p><strong>UICOLLECTIONVIEW 代码片段</strong></p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> viewDidLoad() {
    <span class="keyword">super</span>.viewDidLoad()

    registerForPreviewingWithDelegate(<span class="keyword">self</span>, sourceView: tableView)
}

<span class="func"><span class="keyword">func</span></span> previewingContext(previewingContext: <span class="type">UIViewControllerPreviewing</span>, viewControllerForLocation location: <span class="type">CGPoint</span>) -&gt; <span class="type">UIViewController</span>? {
    guard <span class="keyword">let</span> indexPath = collectionView?.indexPathForItemAtPoint(location) <span class="keyword">else</span> { <span class="keyword">return</span> <span class="built_in">nil</span> }

    guard <span class="keyword">let</span> cell = collectionView?.cellForItemAtIndexPath(indexPath) <span class="keyword">else</span> { <span class="keyword">return</span> <span class="built_in">nil</span> }

    guard <span class="keyword">let</span> detailVC = storyboard?.instantiateViewControllerWithIdentifier(<span class="string">"DetailViewController"</span>) <span class="keyword">as</span>? <span class="type">DetailViewController</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="built_in">nil</span> }

    <span class="keyword">let</span> photo = photos[indexPath.row]
    detailVC.photo = photo

    detailVC.preferredContentSize = <span class="type">CGSize</span>(width: <span class="number">0.0</span>, height: <span class="number">300</span>)

    previewingContext.sourceRect = cell.frame

    <span class="keyword">return</span> detailVC
}
</code></pre><h2 id="UIPREVIEWACTIONITEMS">UIPREVIEWACTIONITEMS</h2>
<p>当用户在 PreViewing Controller 的界面，手指往上推，会从屏幕底部弹出一个类似 actionsheet 的界面，这个是 <code>UIPreviewActions</code>。那如何给指定的 preViewController 自定义这些 <code>UIPreviewActions</code>？ 方法很简单，override UIViewController 中的 preViewActionItems() 方法，在该方法中定义好 actionItems 的数组就好了：</p>
<pre><code>override func previewActionItems<span class="function"><span class="params">()</span> -&gt;</span> [UIPreviewActionItem] {

    <span class="reserved">let</span> likeAction = UIPreviewAction<span class="function"><span class="params">(title: <span class="string">"Like"</span>, style: .Default)</span> { <span class="params">(action, viewController)</span> -&gt;</span> Void <span class="keyword">in</span>
        <span class="built_in">print</span>(<span class="string">"You liked the photo"</span>)
    }

    <span class="reserved">let</span> deleteAction = UIPreviewAction<span class="function"><span class="params">(title: <span class="string">"Delete"</span>, style: .Destructive)</span> { <span class="params">(action, viewController)</span> -&gt;</span> Void <span class="keyword">in</span>
        <span class="built_in">print</span>(<span class="string">"You deleted the photo"</span>)
    }

    <span class="reserved">let</span> groupAction = UIPreviewActionGroup (<span class="attribute">title</span>: <span class="string">"Group"</span>, <span class="attribute">style</span>: .Default, <span class="attribute">actions</span>: [likeAction, deleteAction])
    <span class="keyword">return</span> [likeAction, deleteAction, groupAction]

}
</code></pre><p>另外苹果还提供了 <code>UIPreviewActionGroup</code>，顾名思义就是把几个UIPreviewActionItem操作放到一起，组成一个组。</p>
<h2 id="POPPING">POPPING</h2>
<p>poping 操作处理起来相对简单。在回调函数中</p>
<pre><code><span class="func"><span class="keyword">func</span></span> previewingContext(previewingContext: <span class="type">UIViewControllerPreviewing</span>, commitViewController viewControllerToCommit: <span class="type">UIViewController</span>) {
    <span class="comment">//Here's where you commit (pop)</span>
}
</code></pre><p>我们需要根据preViewingContext来确定poping的时候需要commit的ViewController就好了。</p>
<h2 id="WEBVIEW_PEEK_AND_POP">WEBVIEW PEEK AND POP</h2>
<p>让 <code>UIWebView</code> 和 <code>WKWebview</code> 支持 Peek&amp;Pop就很简单了：</p>
<pre><code>webView.<span class="variable">allowsLinkPreview =</span> <span class="constant">true</span>
</code></pre><h2 id="结语">结语</h2>
<p>以上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/10/25/Peek-and-pop/" data-id="0p4hjl0ad9b8ktle" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS9-Quick-Actions-shortcut" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/09/30/iOS9-Quick-Actions-shortcut/">3D-Touch(1) iOS9 Quick Actions Shortcut</a>
  

      </header>
    
    <time class="article-date" datetime="2015-09-30T11:24:13.000Z" itemprop="datePublished">09-30-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>新的iPhone6s, iPhone6s P 在不久之前的 WWDC 上面发布了，这个版本的iPhone最大的卖点应该是在它的屏幕拥有了 3D Touch 的功能。iOS 9 中已经包含了这一硬件功能所提供API，3D Touch API分成三个部分: Quick Actions， peek and pop,以及 Pressure Sensitivity.考虑到苹果的一贯作风，如果你的APP中集成iPhone的新特性，新的API，被苹果商店推荐的概率也会增大一点。本文将为大家介绍如何快速的添加 Quick Actions shortcut 功能。</p>
<h2 id="Home_Screen_Quick_Actions">Home Screen Quick Actions</h2>
<p>通过主屏幕的应用icon，可以用 3D Touch 呼出一个快捷列表，用户可通过这个列表快速定位应用功能模块。iOS9提供了两种屏幕标签，分别是静态标签和动态标签。且iOS9最多展示四个快捷键给用户，系统会优先展示静态的快捷键，当静态的快捷键不够四个，会添加动态的快捷键到列表。</p>
<h3 id="静态快捷键的添加">静态快捷键的添加</h3>
<p>打开 Info.plist, 在该文件中添加如下键值：</p>
<p><img src="http://cp0000.github.io/assets/static_shortcut.jpg" alt="static_shortcut"></p>
<p>添加一个key为<code>UIApplicationShortcutItems</code>的数组，数组中添件的元素就是静态标签，每个标签我们可以配置下面的键值：</p>
<ul>
<li>UIApplicationShortcutItemType (required) : 快捷标签的唯一字符串标示</li>
<li>UIApplicationShortcutItemTitle (required): 快捷标签的标题，会显示在UI上</li>
<li>UIApplicationShortcutItemSubtitle (optional): 副标题，会显示在UI上</li>
<li>UIApplicationShortcutItemIconType (optional): 系统提供的icon，全部列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/index.html#//apple_ref/c/tdef/UIApplicationShortcutIconType" target="_blank" rel="external">UIApplicationShortcutIcon_Class</a></li>
<li>UIApplicationShortcutItemIconFile (optional): 自定义icon（如果填写了该项，则系统自动ignore UIApplicationShortcutItemIconType）。图片需要时正方形的，35<em>35的倍数（试过100</em>100也是Ok的），并且单色。</li>
<li>UIApplicationShortcutItemUserInfo (optional): 传值用</li>
</ul>
<p>详情请<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW36" target="_blank" rel="external">看这里</a></p>
<p>当在Info.plist 中添加好了需要的标签之后。运行程序便可得到以下效果：</p>
<p><img src="http://cp0000.github.io/assets/shortcut2.jpg" alt="shortcut2"></p>
<p>P.S 关于如何在模拟器中调试ShortCutMenu，请见文章最后一节<a href="#jump">模拟器上测试Shortcut</a>。</p>
<h3 id="动态标签的添加">动态标签的添加</h3>
<p>所谓动态标签，就是我们可以通过代码来添加标签，相关的类有：</p>
<ul>
<li>UIApplicationShortcutItem 3DTouch标签的类</li>
<li>UIApplicationShortcutIcon 标签中图片Icon的类</li>
</ul>
<h3 id="响应标签的行为">响应标签的行为</h3>
<p>当点击标签进入应用时，我们需要在代码对不同标签的做处理。在iOS 9 中，UIApplicationDelegate 新增了方法：</p>
<pre><code><span class="pp">- <span class="params">(void)</span> application:<span class="params">(<span class="variable">UIApplication</span> *)</span>application performActionForShortcutItem:<span class="params">(<span class="variable">UIApplicationShortcutItem</span> *)</span>shortcutItem completionHandler:<span class="params">(void (^)</span><span class="params">(<span class="variable">BOOL</span>)</span>)completionHandler</span>
</code></pre><p>当通过标签进入APP时，appdelegate中会回调到这个函数。当你处理完了标签需要做的工作之后，需要执行 <code>completionHandler</code>。</p>
<p>这里有一个地方需要特别注意一下，用户按下标签进入应用要分成两种状况：启动APP，APP从后台回到前台。你需要在 <code>application:didFinishLaunchingWithOptions:</code> 或 <code>application:willFinishLaunchingWithOptions:</code> 中的一个去检查字典 <code>launchOptions</code> 中是否包含了<code>UIApplicationLaunchOptionsShortcutItemKey</code>。如果有这个key，则表示是启动app。你需要在此时设置好APP的view层级，并且为 application:willFinishLaunchingWithOptions: 返回 false。这样就可以阻止 <code>application(_:performActionForShortcutItem:completionHandler:)</code> 被调用，避免标签处理逻辑被处理两次。</p>
<p>以下是 sample code (Objective_c)，demo 放在github上面<a href="https://github.com/cp0000/shortcutDemo" target="_blank" rel="external">shortcutDemo</a></p>
<p>另外苹果官方提供了 swift 的<a href="https://developer.apple.com/library/prerelease/ios/samplecode/ApplicationShortcuts/Introduction/Intro.html" target="_blank" rel="external">sample code</a></p>
<pre><code><span class="preprocessor">#import <span class="title">"AppDelegate.h"</span></span>

<span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) UIApplicationShortcutItem * launchedShortcutItem;

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span>

- (<span class="built_in">BOOL</span>) handledShortCutItem: (UIApplicationShortcutItem *) shortcutItem
{
    <span class="built_in">BOOL</span> handled = <span class="literal">NO</span>;
    <span class="keyword">if</span> (!shortcutItem<span class="variable">.type</span>) <span class="keyword">return</span> <span class="literal">NO</span>;
    <span class="keyword">if</span> (![shortcutItem<span class="variable">.type</span> isKindOfClass:[<span class="built_in">NSString</span> class]]) <span class="keyword">return</span> <span class="literal">NO</span>;

    UIAlertController * alertController = [UIAlertController alertControllerWithTitle:<span class="string">@"Shortcut Handled"</span> message:shortcutItem<span class="variable">.localizedTitle</span> preferredStyle: UIAlertControllerStyleAlert];
    UIAlertAction *alertAction = [UIAlertAction actionWithTitle:<span class="string">@"OK"</span> style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
    }];
    [alertController addAction: alertAction];

    [<span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> presentViewController: alertController animated: <span class="literal">YES</span> completion:<span class="literal">nil</span>];

    <span class="keyword">return</span> handled;
}

- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions {
    <span class="comment">// Override point for customization after application launch.</span>
<span class="comment">//    Dynamic Shortcuts</span>
    UIApplicationShortcutIcon * addIcon = [UIApplicationShortcutIcon iconWithType: UIApplicationShortcutIconTypeAdd];<span class="comment">//Icons should be square, single color,</span>

    UIApplicationShortcutItem * addItem = [[UIApplicationShortcutItem alloc]initWithType: <span class="string">@"add"</span> localizedTitle: <span class="string">@"Add"</span> localizedSubtitle: <span class="literal">nil</span> icon: addIcon userInfo: <span class="literal">nil</span>];

    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.shortcutItems</span> = @[addItem];

    <span class="built_in">BOOL</span> shouldPerformAdditionalDelegateHandling    = <span class="literal">YES</span>;
    <span class="keyword">if</span> (launchOptions[UIApplicationLaunchOptionsShortcutItemKey]) {
        UIApplicationShortcutItem * shortcutItem = launchOptions[UIApplicationLaunchOptionsShortcutItemKey];
        <span class="keyword">self</span><span class="variable">.launchedShortcutItem</span>   = shortcutItem;
        <span class="comment">// This will block "performActionForShortcutItem:completionHandler" from being called.</span>
        shouldPerformAdditionalDelegateHandling     = <span class="literal">NO</span>;
    }
    <span class="keyword">return</span> shouldPerformAdditionalDelegateHandling;
}

- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application {
}

- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application {
    <span class="keyword">if</span>(!<span class="keyword">self</span><span class="variable">.launchedShortcutItem</span>) {
        <span class="keyword">return</span>;
    }
    [<span class="keyword">self</span> handledShortCutItem: <span class="keyword">self</span><span class="variable">.launchedShortcutItem</span>];

    <span class="keyword">self</span><span class="variable">.launchedShortcutItem</span>   = <span class="literal">nil</span>;
}

- (<span class="keyword">void</span>) application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler
{
    <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> handledShortCutItem: shortcutItem];
    completionHandler(result);
}

<span class="keyword">@end</span>
</code></pre><p><span id="simulator_shortcuts"></span></p>
<h3 id="模拟器上测试Shortcuts">模拟器上测试Shortcuts</h3>
<p>Xcode7.0 的模拟器是没办法之间触发出 3D Touch 事件的，好在有人开发出了插件<a href="https://github.com/DeskConnect/SBShortcutMenuSimulator" target="_blank" rel="external">SBShortcutMenuSimulator</a>.实用也很简单，只需要follow readme 中的 usage 便可。以下摘录</p>
<pre><code>git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/DeskConnect/SBShortcutMenuSimulator.git
<span class="keyword">cd</span> SBShortcutMenuSimulator
<span class="keyword">make</span>

xcrun simctl spawn booted launchctl <span class="keyword">debug</span> <span class="built_in">system</span>/<span class="keyword">com</span>.apple.SpringBoard --environment DYLD_INSERT_LIBRARIES=$PWD/SBShortcutMenuSimulator.dylib
xcrun simctl spawn booted launchctl <span class="keyword">stop</span> <span class="keyword">com</span>.apple.SpringBoard

<span class="keyword">echo</span> <span class="string">'com.apple.mobilecal'</span> | nc <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">8000</span>
</code></pre><p>‘com.apple.mobilecal’ 替换成你需要测试的app的bundle就可以了，例如我的是 <code>chengpei.shortcutDemo</code></p>
<pre><code><span class="title">echo</span> <span class="string">'chengpei.shortcutDemo'</span> | nc <span class="number">127.0.0.1</span> <span class="number">8000</span>
</code></pre><p>上面的命令全都在clone的SBShortcutMenuSimulator目录下执行。</p>
<h3 id="结语">结语</h3>
<p>以上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/09/30/iOS9-Quick-Actions-shortcut/" data-id="8yql702iejce3h7i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-There-will-be-blood" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/09/03/There-will-be-blood/">There Will Be Blood</a>
  

      </header>
    
    <time class="article-date" datetime="2015-09-03T15:47:22.000Z" itemprop="datePublished">09-03-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Movie/">Movie</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://cp0000.github.io/assets/there_will_be_blood.jpg" alt="pic"></p>
<p>&gt;<br>如果你喜欢《老无所依》，去看《血色将至》<br>如果你喜欢西部片，去看《血色将至》<br>如果你喜欢电影，去看《血色将至》  </p>
<p>电影讲述的是一个银矿勘探者如何通过自身的艰苦奋斗最终成为石油大亨的故事。在观看影片的过程中，主角丹尼尔身上的所表现出来的气质，和我们今天所传扬的创业者身上的气质有着极大相似之处。（当然这些创业者的气质我也是从书中，网络中得来）。其中有两个场景给我映像极其深刻。</p>
<ul>
<li><p>场景一：丹尼尔刚刚开发的新油井发生不幸发生意外，井喷了。丹尼尔的儿子 H.W 在井喷中意外受伤。丹尼尔把受伤的儿子抱到安全地带之后，在明知道儿子因伤至聋，极其需要爸爸的情况下，毅然丢下了儿子，跑去事故现场救灾。当身边的伙伴皱着眉头看着大火的时候，丹尼尔却笑着说：你干嘛要愁眉头，井喷证明了下面埋藏着无穷的石油，我们要发财了。此时，他已经把H.W的情况抛之脑后，心里所想全部是采油的事情。当伙伴问他H.W怎么样了，他才想起来儿子情况很不好。影片此后的镜头就是海报中的场景，丹尼尔指挥者工人用炸药把油井炸封起来。</p>
</li>
<li><p>第二个场景是，为了运输开采出来的石油。丹尼尔决心建一条油管通往大海。但油管铺设遇到了需要通过一块没有弄到租借权的土地。为了能够租下这块地，丹尼尔忍辱负重跑去教堂接受小人Eli神父洗礼。洗礼过程中Eli出于对丹尼尔的嫉妒狠狠的打了几个丹尼尔耳光（个人觉得Eli是在嫉妒丹尼尔，嫉妒他给小镇带来了繁荣，嫉妒他的石油生意）。但此时的丹尼尔并不在意被Eli侮辱，他只在意这块地终于租下来了，石油管道的铺设有谱了，自己的石油生意真的要做起来了。（这里有个细节，在还没有和土地主人谈妥之前，丹尼尔已经在那块地上面打桩测量油管路线。这一情节，也表明了丹尼尔对自己能够说明别人把地租给他的强大自信）</p>
</li>
</ul>
<p>这两个场景都表现出了，丹尼尔对石油开采的极度专注和极大热情。开采过程的任何困难，挫折对于丹尼尔来说都不是问题，井喷不怕，火灾不怕，被小人侮辱无所谓。他眼中只关心和石油相关的事情，他探索油田，建筑油井，铺设油管，一切都是为了自己的石油生意。在生意路上遇到的问题，丹尼尔唯一做的就是自信满满的去解决它。</p>
<p>如果从资本家，企业家的角度来看丹尼尔，他无意是成功创业家的典范。创业后辈们无疑可以从他的事迹中汲取到很多的经验和养分。而他对当地石油的开采，无疑也提高当地人民的生活水平。</p>
<p>但这部电影不是单单讲述一个成功企业家的创业故事，还描述了丹尼尔作为一个人与这个上世界其它人的关系和情感。</p>
<p>我想绝大多数人应该都会害怕孤独吧，开心没人分享，失落无人倾诉。丹尼尔人生就是如此，影片开篇十几分钟跟默片一般，没有一句台词，镜头中只有丹尼尔一个人胡子拉渣的孤独的在矿井中勘探。有了油井，挣了初始资本之后，丹尼尔则每次都会带着H.W去做和卖家谈买卖。美国是一个清教徒国家，大家信上帝，非常重视家庭，大部分都会买亲情的帐。当在H.W变聋之后，为了专注工作，丹尼尔又能冷酷地把儿子从自己身边送走，寄养在别处。不过每个人都渴望亲情，渴望被别人所理解，丹尼尔内心深处也是如此。冒牌弟弟Henry的到来，让他在一段时间好似找到了久违的亲情。但可惜这个Henry是冒牌的，丹尼尔发现真相之后，开枪直接打死了冒牌的Henry，尽管冒牌Henry是唯一能和丹尼尔说得上话的人。</p>
<p>野心，孤独，对权力的欲望，虚伪，憎恶，不信任，丧失人性，这是丹尼尔作为人的一面。但与此同时，他却又是成功的资本家，他成功创业的事迹又会被当今的社会所传颂。或许按中国人的智慧，这就叫是非功过三七开吧。</p>
<p>熙熙皆为利来，攘攘皆为利往。丹尼尔这样的人在当代中国应该很受崇拜吧，应该会。</p>
<p>最后，摘录片中我喜欢的一段台词，也是丹尼尔唯一一次吐露自己心声的一段对话</p>
<p><strong>亨利：</strong><br>　　……你为什么离家出走？我知道你和父亲的关系不好。<br><strong>丹尼尔：</strong><br>　　我替地质调查局工作，去了堪萨斯。<br>　　我没法留在家里，不可能。<br>　　我不喜欢解释自己的行为。<br>　　……<br><strong>丹尼尔：</strong><br>　　你是个愤怒的人吗，亨利？<br><strong>亨利：</strong><br>　　愤怒什么？<br><strong>丹尼尔：</strong><br>　　你嫉妒吗？你会嫉妒别人吗？<br><strong>亨利：</strong><br>　　我想不会。不嫉妒。<br><strong>丹尼尔：</strong><br>　　我有一颗争强好胜的心。<br>　　我不想看到别人成功。<br>　　我憎恨大多数人。<br><strong>亨利：</strong><br>　　我已经没有那种心气了……<br>　　辛苦工作却总不能成功――所有的失败让我……我就不在乎了。<br><strong>丹尼尔：</strong><br>　　我心里有，你心里就也有。<br>　　有时候我注视着人群，看不到任何值得我爱的东西。<br>　　我只想挣到足够的钱好让我远离所有的人。<br>　　……<br><strong>丹尼尔：</strong><br>　　我不想提那些事。<br>　　我看到人们最丑陋的一面，亨利。<br>　　我能得到我所要的一切，根本用不着去看那些丑陋背后还有什么。<br>　　经过这么多年，我的仇恨一点一滴越积越深。<br>　　你来这儿，给了我喘息的机会。我自己一个人坚持不下去……同这些人纠缠。   </p>
<p><strong>英文版</strong></p>
<p><strong>Plainview</strong>: Are you an angry man. Henry?<br><strong>Henry Brands</strong>: About what?<br><strong>Plainview</strong>: Are you envious? D’you get envious?<br><strong>Henry Brands</strong>: I don’t think so. No.<br><strong>Plainview</strong>: I have a competition in me. I want no one else to succeed. I hate most people.<br><strong>Henry Brands</strong>: That part of me is gone. Working and not succeeding- all my, uh… failures has left me, uh… I just don’t… care.<br><strong>Plainview</strong>: Well, if it’s in me, it’s in you. There are times when I… I look at people and I see nothing worth liking. I want to earn enough money I can get away from everyone.<br><strong>Henry Brands</strong>: What will you do about your boy?<br><strong>Plainview</strong>: I don’t know. Uhhhh, maybe it’ll change. Does your sound come back to you? I don’t know. Maybe no one knows that. A doctor might not know that.<br><strong>Henry Brands</strong>: Where’s his mother?<br><strong>Plainview</strong>: I don’t want to talk about those things. I see the worst in people, Henry. I don’t need to look past seeing them to get all I need. I’ve built up my hatreds over the years, little by little. Having you here gives me a second breath of life. I can’t keep doing this on my own… with these, umm… people.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/09/03/There-will-be-blood/" data-id="2ae9qd6bvtr0vm7t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-openradarstream" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/08/30/openradarstream/">Openradar Stream</a>
  

      </header>
    
    <time class="article-date" datetime="2015-08-30T14:02:42.000Z" itemprop="datePublished">08-30-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://cp0000.github.io/assets/radardetector2.jpg" alt="Openradar Stream"></p>
<h4 id="写在前面">写在前面</h4>
<p>随着夏天的结束，9月份的到来，又到了苹果秋季发布新iPhone的季节了。我和绝大多数苹果用户一样对新的iPhone自然保留着一份期待。不过理智告诉我这次新的iPhone的release，应该不会给大家带来很大的惊喜。我猜测 iPhone6s 应该是一款针对 iPhone6 的升级产品。就像 iOS 9 是针对 iOS 8的一次升级，苹果公司内部在这一次的迭代中，主要精力应该是会放在“还债”上，之前release了太多的feature，遗留了太多的bug，会在这一次修复掉。</p>
<h4 id="Openradar_stream_的来由">Openradar stream 的来由</h4>
<p>和大多数 iOS developers 一样，我也在第一时间安装了 iOS 9 beta版本。满足了尝鲜感之后，随着而来就是 beta 系统的不稳定，以及各种的bug。用 iOS 9 进行开发的过程中，我遇到了许许多多的坑，对于一些系统的bug，会花费掉我很多的时间去debug。然后，我发现了<a href="http://www.openradar.appspot.com/" target="_blank" rel="external">openradar</a>。一个 open database of radars for Apple bug。从openradar 上，你可以看到其他开发者提交的bug，这当然会为你省去很多的时间，帮助你避免很多的坑。</p>
<p>后来我想我是不是应该做一个自动的脚本，定时的去抓取这个网页上面的信息，然后发到微博上。关注这个微博的人就可以在自己的时间线上面看到最新的bug了。这样做的好处是，一来你了解到bug信息，下次你遇到类似的问题，会联想到之前看过的bug信息，省去大量的时间。二来，刷微博的时候，还顺便学习了新知识，就没那么大的罪恶感了～。为此，我写一个tiny project，auto radarstream。</p>
<h4 id="具体工作">具体工作</h4>
<p>完成openradarstream，有以下事情需要去做</p>
<p><strong>前期工作</strong></p>
<ul>
<li>申请一个微博账号，并申请微博OpenApi，获取到<code>apikey</code>和<code>apisecret</code>。</li>
<li>获取到微博的 accessToken， expires</li>
</ul>
<p><strong>开发工具</strong></p>
<ul>
<li>language: python</li>
<li>database: sqlite</li>
</ul>
<p><strong>细节</strong></p>
<ul>
<li>设置好微博的环境，其中微博的OpenAPI,使用开源库<a href="https://github.com/michaelliao/sinaweibopy" target="_blank" rel="external">sinaweibopy</a></li>
<li>初始化数据库</li>
</ul>
<pre><code>    <span class="function"><span class="keyword">def</span> <span class="title">initDB</span> <span class="params">()</span>:</span>
        <span class="keyword">print</span> <span class="string">'initDB ...'</span>
        db = sqlite3.connect(sqlite_file)
        cursor = db.cursor()
        cursor.execute(<span class="string">'''CREATE TABLE IF NOT EXISTS
                          bugs(id INTEGER PRIMARY KEY, bugid TEXT, status TEXT, originator TEXT, product TEXT, title TEXT)'''</span>)
        db.commit()
</code></pre><ul>
<li><p>获取网站信息，并做相关处理。</p>
<p>  第一步利用 urllib2 获取<a href="http://openradar.appspot.com/" target="_blank" rel="external">openradar</a>主页信息。<br>  第二步对获取到的信息，利用 BeautifulSoap 对<code>html</code>进行解析，得到一个buglist。<br>  第三步，由于网页上面的信息是按时间降序的，而我们是希望最新的bug，在本次最后一个发布，这样这条bug会出现在微博主页时间线的最上头。所以我们这里反转buglist。<br>  第四步，遍历buglist，发布没有发布的bug，并把发布过的bug插入数据库存档。</p>
</li>
</ul>
<p>项目在Github上面的地址：<a href="https://github.com/cp0000/radarstream" target="_blank" rel="external">radarstream</a>。</p>
<h4 id="最后">最后</h4>
<p><strong>To track open radar posts, please follow <a href="http://weibo.com/p/1005051666350201" target="_blank" rel="external">@openradarstream</a></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/08/30/openradarstream/" data-id="4cnnesk6twtycgg4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-UICollectionView-Has-Easy-Reording-On-iOS9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/08/22/UICollectionView-Has-Easy-Reording-On-iOS9/">UICollectionViews Now Have Easy Reordering （译）</a>
  

      </header>
    
    <time class="article-date" datetime="2015-08-22T01:52:28.000Z" itemprop="datePublished">08-22-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS_9-0_UICollectionView_拖拽效果实现">iOS 9.0 UICollectionView 拖拽效果实现</h1>
<blockquote>
<p>原文 <a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/" target="_blank" rel="external">UICollectionViews Now Have Easy Reordering</a></p>
</blockquote>
<p>在<code>UICollectionView</code> 刚出来的时候，我就对其产生了很大的兴趣。相比它的大哥 <code>UITableView</code>，它更加容易进行一些自定义的操作。我们组现在在项目中使用 <code>UICollectionView</code> 要多于 <code>UITableView</code>。伴随着 iOS 9 的 release，<code>UICollectionView</code>排序（动态拖拽）更加简单。在这之前，如果想对 <code>UICollectionView</code> 进行动态拖拽是非常困难的，要想实现动态拖拽，需要去做非常多的工作。话不多说，我们看一下新的 API。文章用到的Sample地址<a href="https://github.com/nshintio/uicollectionview-reordering" target="_blank" rel="external">uicollectionview-reordering</a>。</p>
<p>实现拖动排序最简单的办法是使用 <code>UICollectionViewController</code>, 在 <code>UICollectionViewController</code> 中新增了一个属性  <code>installsStandardGestureForInteractiveMovement</code>, 通过添加手势对cells进行重排。该属性是BOOL型，默认值为 YES。     我们所需要做的，只要重载下面这个方法就好了.</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> collectionView(collectionView: <span class="type">UICollectionView</span>,
    moveItemAtIndexPath sourceIndexPath: <span class="type">NSIndexPath</span>,
    toIndexPath destinationIndexPath: <span class="type">NSIndexPath</span>) {
    <span class="comment">// move your data order</span>
}
</code></pre><p>当程序中重载了<code>moveItemAtIndexPath</code>，collectionView 就认为 cell 是可以移动的。</p>
<pre><code>![<span class="link_label">reordering-01</span>](<span class="link_url">http://nshint.io/images/uicollectionview-reordering/1.gif</span>)
</code></pre><p>那如果需要给某一个 <code>UIViewController</code> 中 collection view 实现动态拖动效果，该如何实现呢？事情会变的稍微复杂一点。除了需要实现<code>UICollectionViewDataSource</code>中上面提到的代理方法，还需要重写 <code>installsStandardGestureForInteractiveMovement</code>。不过不用当心，实现起来蛮蛮容易。这里我们需要长按手势<code>UILongPressGestureRecognizer</code>，它能够完全满足拖拽需求。</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> viewDidLoad() {
    <span class="keyword">super</span>.viewDidLoad()
    longPressGesture = <span class="type">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"handleLongGesture:"</span>)
    <span class="keyword">self</span>.collectionView.addGestureRecognizer(longPressGesture)
}

<span class="func"><span class="keyword">func</span></span> handleLongGesture(gesture: <span class="type">UILongPressGestureRecognizer</span>) {

    <span class="keyword">switch</span>(gesture.state) {

    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Began</span>:
        guard <span class="keyword">let</span> selectedIndexPath = <span class="keyword">self</span>.collectionView.indexPathForItemAtPoint(gesture.locationInView(<span class="keyword">self</span>.collectionView)) <span class="keyword">else</span> {
            <span class="keyword">break</span>
        }
        collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)
    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Changed</span>:
        collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view!))
    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Ended</span>:
        collectionView.endInteractiveMovement()
    <span class="keyword">default</span>:
        collectionView.cancelInteractiveMovement()
    }
}
</code></pre><p>这段代码主要是给 collectionView 添加一个长手势识别器，并根据手势的不同状态调用collectionView的相关方法。</p>
<ul>
<li><code>beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)</code>: 该方法在开始拖拽某个cell时被调用</li>
<li><code>updateInteractiveMovementTargetPosition(targetPosition:CGPoint)</code>: 根据手势更新拖拽cell的位置</li>
<li><code>endInteractiveMovement()</code>: 手势结束时调用，结束拖拽</li>
<li><code>cancelInteractiveMovement()</code>: 手势取消时调用，取消拖拽</li>
</ul>
<p>这样就实现了需要的拖拽效果：</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/2.gif" alt="reordering_collection_view"></p>
<p>这段代码出来的效果和 <code>UICollectionViewController</code> 是一致的。很厉害吧，但更厉害的是我们可以用上面的方法对自定义的 collection view layout 进行拖拽。下面我们来实现一个简单的瀑布流。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/3.gif" alt="reordering_waterfall"></p>
<p>昂～，看起来还凑合，但在移动的时候cell的size被改变了呢，如何才能保持cell的size不变呢？ <code>UICollectionViewLayout</code>提供了相关办法可以帮助我们解决这个问题。</p>
<pre><code><span class="input"><span class="prompt">func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],
    withTargetPosition targetPosition: CGPoint,
    previousIndexPaths: [NSIndexPath],
    previousPosition: CGPoint) -&gt;</span> <span class="constant">UICollectionViewLayoutInvalidationContext</span></span>
<span class="input"><span class="prompt">
func invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths(indexPaths: [NSIndexPath],
    previousIndexPaths: [NSIndexPath],
    movementCancelled: Bool) -&gt;</span> <span class="constant">UICollectionViewLayoutInvalidationContext</span></span>
</code></pre><ul>
<li>第一个函数会在 cells 拖拽过程中被调用</li>
<li><p>第二个函数会在拖拽结束时候被调用。有了这些信息，我们可以使用一点小技巧去实现cell size不被改变的功能。</p>
<p>  internal override func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],</p>
<pre><code>  withTargetPosition targetPosition: <span class="built_in">CGPoint</span>,
  previousIndexPaths: [<span class="built_in">NSIndexPath</span>],
  previousPosition: <span class="built_in">CGPoint</span>) -&gt; UICollectionViewLayoutInvalidationContext {

  var context = <span class="keyword">super</span><span class="variable">.invalidationContextForInteractivelyMovingItems</span>(targetIndexPaths,
      withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,
      previousPosition: previousPosition)

  <span class="keyword">self</span><span class="variable">.delegate</span>?<span class="variable">.collectionView</span>!(<span class="keyword">self</span><span class="variable">.collectionView</span>!, moveItemAtIndexPath: previousIndexPaths[<span class="number">0</span>],
      toIndexPath: targetIndexPaths[<span class="number">0</span>])

  <span class="keyword">return</span> context
</code></pre><p>  }</p>
</li>
</ul>
<p>解决方法很直接。获取当前被拖拽的cell的起始indexPath和目标indexPath,然后调用UICollectionViewDataSource代理方法移动当前正在被拖拽的cell。</p>
<p>一个可以拖拽的的collectionView带来体验效果真的非常棒～</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/08/22/UICollectionView-Has-Easy-Reording-On-iOS9/" data-id="gsvcmkwxj9jbfusp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mdfind-note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/08/02/mdfind-note/">Spotlight &amp; MDFind</a>
  

      </header>
    
    <time class="article-date" datetime="2015-08-02T03:31:18.000Z" itemprop="datePublished">08-02-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Indexing_服务">Indexing 服务</h4>
<p>Maocx 系统的搜索服务 <code>spotlight</code> 想必大家都用过。它可以很便捷的帮我们找到想要的文件。</p>
<p>先举个例子，在 spotlight 中输入 _loadBlock， 我的电脑会出现以下结果：</p>
<p><img src="http://cp0000.github.io/assets/loadBlock.png" alt="loadBlock"></p>
<p>spotlight 帮我找到了包含 <code>_loadBlock</code> 这个字符串的文件。</p>
<p>想象下，电脑硬盘中存储着如此多的文件，<strong>spotlight 是如何如此快速的查询到包涵这个字符串的文件的？</strong></p>
<p>在查找答案之前，我们不妨自己来试着猜想一下，如果这个功能交给我们自己来做，我们会采用哪种技术方案来实现？<br>关于文件搜索，首先能想到的最简单的方法自然是遍历目录逐个文件对比，使用 <code>find</code> 的方式去查询。不过稍微想一下，如果使用这种方法在整个硬盘上找一个文件，得等多久才能找到一个文件。这肯定不是解决方案。<strong>那答案是什么？</strong></p>
<p>我们不妨先把目光放到<code>搜索</code>这两个字上。提到搜索，首先想到的应该会是Google。而关于Google搜索引擎的工作原理，最简单的解释是：通过代码在全球收集信息，建立词组的索引数据库。Google处理用户的搜索请求，可以简单的理解成在索引数据库中查找结果的过程。<br>那 Macosx 的本地文件搜索会不会也是采取这种索引数据库的方式来实现的？答案是肯定的。Macosx 实现了自己的<code>indexing</code>的索引服务。那什么是<code>indexing</code>索引服务器，简单来讲： Macosx 系统会在平时建立磁盘上所有文件和目录的索引关系，维护出一个索引表，当要查找信息时直接从索引中查询即可。这个索引就好像是一本书的目录一样，我们根据自己要找的内容翻到对应的页面。</p>
<p>当然这当中还有很多复杂的处理过程，如当机器运行时，硬盘的文件产生变化，如何重新加载索引文件。更多的细节，我也没找出相关的文档来得到答案。先留个坑在这里吧。不过我们可以从其他开源的文件查询项目中了解一下业界对于这一块的处理方式。这里推荐 <a href="https://lucene.apache.org/" target="_blank" rel="external">Lucene</a> 给大家研究。（Lucene是一套用于全文检索和搜素的开源项目）。</p>
<h4 id="mdfind">mdfind</h4>
<p>用 spotlight 的图形界面查询文件是很方便.但是我平常的工作过程中，常常需要知道文件的绝对路径，而图形界面并没有显示出来。<strong>关于如何在spotlight界面显示文件的详细路径</strong>，这里有个小 tips，具体操作是：选中某个搜索结果，长按 command 键，此时，界面右下方会出现文件的详细路径。不过如果文件路径太长，界面会显示不全，而且也有很好的没法去拷贝这个路径。</p>
<p><strong>那如何解决文件路径显示不全，无法拷贝文件路径的问题呢？</strong></p>
<p>Macosx 提供了终端执行命令<code>mdfind</code>，我们可以在 terminal 中使用<code>mdfind</code>来进行索引查询。比如要查询出文件内容中包含字符串 “_loadBlock”, 在ternimal中输入以下命令即可：</p>
<pre><code>mdfind 'kMDItemTextContent=<span class="string">"_loadBlock"</span>' 
</code></pre><p>results:</p>
<pre><code>/<span class="keyword">opt</span>/dev/appstore_cracked/StoreKit_headers/SKStorePageViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/appstore_cracked/StoreKit_headers/SKStoreProductViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/iTunesStoreUI.framework/SUWebViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/iTunesStoreUI.framework/SUStorePageViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/iTunesStoreUI.framework/SUPreviewOverlayViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/PrivateFrameworks/Preferences.framework/PSLazyImagePromise.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/Frameworks/StoreKit.framework/SKStoreProductViewController.<span class="keyword">h</span>
/<span class="keyword">opt</span>/dev/iOS-Runtime-Headers/Frameworks/StoreKit.framework/SKStorePageViewController.<span class="keyword">h</span>
</code></pre><p>对比终端查询结果和图一中的结果，会发现有两点出入：</p>
<ul>
<li>(1) 图一中的 PrivateFrameworks, Frameworks 整个目录都没有被查出来。这里我猜测应该是Soptlight这个应用是对查询结果进行了筛选，把PrivateFrameworks, Frameworks目录下的文件从查询结果中剔除掉了。</li>
<li>(2) 图一中出现的nsBlocklistService.js，在terminal的查询结果中并没有出现。为了找出原因，我分别查看下”_loadBlock”在各个文件中的上下文，以下是节选</li>
</ul>
<p>nsBlocklistService.js</p>
<pre><code><span class="keyword">this</span>._loadBlocklist();
</code></pre><p>SKStorePageViewController</p>
<pre><code><span class="title">CDUnknownBlockType</span> _loadBlock;
</code></pre><p>看上去问题应该是出在<code>_loadBlock</code>前后是否能跟别的字符串上，修改查询语句</p>
<pre><code>mdfind 'kMDItemTextContent=<span class="string">"_loadBlock*"</span>' 
</code></pre><p>果然可以查询到结果</p>
<pre><code><span class="regexp">/Project/m</span>ozilla-central<span class="regexp">/toolkit/m</span>ozapps<span class="regexp">/extensions/</span>nsBlocklistService.js
</code></pre><p>关于 mdfind 的一些常用查询语法，可参考 <a href="http://osxnotes.net/spotlight.html" target="_blank" rel="external"><code>osxnotes</code></a>，这里列举了大量的例子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/08/02/mdfind-note/" data-id="uqgk9tnhyipdww2w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac-power-user/">mac power user</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oc-checklist-answers" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/07/23/oc-checklist-answers/">Objc Interview Checklist Answers</a>
  

      </header>
    
    <time class="article-date" datetime="2015-07-23T13:12:55.000Z" itemprop="datePublished">07-23-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="@property中有哪些属性关键字？">@property中有哪些属性关键字？</h4>
<p>nonatomic (thread-unsafe)<br>atomic (default, thread safe)</p>
<p>strong<br>weak<br>assign<br>copy</p>
<p>getter (custom getter method name)<br>setter (custom setter method name)</p>
<p>readwrite (default)<br>readonly</p>
<h4 id="weak属性需要在dealloc中置nil么？">weak属性需要在dealloc中置nil么？</h4>
<p>不需要，runtime会在weak属性在释放的时候，自动把变量至为 nil;</p>
<h4 id="@synthesize和@dynamic分别有什么作用？">@synthesize和@dynamic分别有什么作用？</h4>
<p>@synthesize 自动生成属性 getter 和 setter 方法.<br>LLVM Compiler 4.0之后，编译器会对@property 属性自动的添加 @synthesize ivar = _ivar,自动帮你生成 getter/setter 方法，以及自动绑定_ivar 实例变量。</p>
<p>@dynamic 是为了告诉编译器，getter/setter 方法将会在其他地方（父类，runtime）实现，这样可以消除warnnig</p>
<h4 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h4>
<p>atomic, assign, readwrite</p>
<h4 id="用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h4>
<p><a href="http://cp0000.github.io/2015/07/19/nsstring-property-copy-or-retain/" target="_blank" rel="external">NSString Property:copy or retain</a></p>
<h4 id="@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？">@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h4>
<p>首先 complier 会根据 @interface 中的 @property 属性自动生成一份属性名前加<code>_</code>的实例变量。LLVM Compiler 4.0 之后，会自动添加@synthesize ivar = _ivar。</p>
<p>自定义的实例变量 _foo 会和 foo 会自动合成。</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> foo;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>
{
    <span class="built_in">NSInteger</span> _foo;
}

- (<span class="keyword">void</span>)viewDidLoad {
    [<span class="keyword">super</span> viewDidLoad];
    _foo = <span class="number">90</span>;
    <span class="built_in">NSLog</span>(<span class="string">@"self.foo: %ld"</span>, (<span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.foo</span>); <span class="comment">//self.foo: 90</span>
}
</code></pre><p>然后还有一个现象：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> foo;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>
{
    <span class="built_in">NSInteger</span> foo;
}
</code></pre><p>complier 会报 warning : Autosynthesized property ‘foo’ will use synthesized instance variable ‘_foo’, not existing instance variable ‘foo’</p>
<h4 id="在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？">在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h4>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> foo;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>
{
    <span class="built_in">NSInteger</span> _foo3;

}
<span class="keyword">@synthesize</span> foo = _foo3;
</code></pre><p>这样 .m 中就可以 _foo3, 开放给外部的接口 foo，可以隐藏实例变量的名称。</p>
<h4 id="objc中向一个nil对象发送消息将会发生什么？">objc中向一个nil对象发送消息将会发生什么？</h4>
<ul>
<li>nil is basically a null pointer (i.e it is the number zero stored in a pointer).</li>
<li>All messages to nil are legal (they won’t cause a  crash), but they dont’t do anything.</li>
<li>All messages to nil return nil, or 0, or 0.0, or NO, depending on the return type.</li>
</ul>
<h4 id="objc中向一个对象发送消息[obj_foo]和objc_msgSend()函数之间有什么关系？">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h4>
<p>简单来讲 compiler 会把 [receiver message] 转换成 objc_msgSend(receiver, selector, arg1, arg2, …)</p>
<h4 id="什么时候会报unrecognized_selector的异常？">什么时候会报unrecognized selector的异常？</h4>
<ul>
<li>the object’s class, the object’s superclass, the root class, all of them are not implement the called message.</li>
<li>the reveiver has been released</li>
</ul>
<h4 id="一个objc对象如何进行内存布局？（考虑有父类的情况）">一个objc对象如何进行内存布局？（考虑有父类的情况）</h4>
<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中</li>
<li>每一个对象内部都有一个isa指针，指向他的类对象，类对象中存放着本对象的 1）对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）<br>2）成员变量的列表<br>3）属性列表</li>
</ul>
<h4 id="一个objc对象的isa的指针指向什么？有什么作用？">一个objc对象的isa的指针指向什么？有什么作用？</h4>
<p>每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例特点，包括成员变量的列表，成员函数的列表等。<br>所有元类的 isa 指针都会指向一个根元类（root <code>metaclass</code>）.</p>
<h4 id="下面的代码输出什么？">下面的代码输出什么？</h4>
<pre><code><span class="variable">@implementation</span> <span class="constant">Son</span> <span class="symbol">:</span> <span class="constant">Father</span>
- (id)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        <span class="constant">NSLog</span>(@<span class="string">"%@"</span>, <span class="constant">NSStringFromClass</span>([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>]));</span>
        <span class="constant">NSLog</span>(@<span class="string">"%@"</span>, <span class="constant">NSStringFromClass</span>([<span class="keyword">super</span> <span class="class"><span class="keyword">class</span>]));</span>
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="variable">@end</span>
</code></pre><p>都是 Son  </p>
<p>调用[self class]，会转换成 id objc_msgSend(id self, SEL op, …)， 在使用 objc_msgSend 时，第一个参数是 Son 当前的这个实例。第二个参数， 先从 Son 类中找 - (Class) class，没找到， 去父类 Father 中找，也没有，再去 Father 的父类 NSObject 中去找，在 NSObject 的类中发现这个 class 方法， 而 NSObject 的 - (Class) class 的实现就是返回 self 的类别，所以上述结果为 Son</p>
<p>objc runtime 开源代码对 - (Class) class 方法的实现</p>
<pre><code>- (<span class="constant">Class</span>) <span class="class"><span class="keyword">class</span> {</span>
    <span class="keyword">return</span> object_getClass (<span class="keyword">self</span>);
}
</code></pre><p>当调用 [super class],会转换成 objc_msgSendSuper 函数。</p>
<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, <span class="keyword">...</span>)
</code></pre><p>其中 objc_super 的结构体为</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>{
   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
};
</code></pre><p>第一步：构造 objc_super 结构体的时候， 结构体第一个成员变量是 self， 第二个成员变量是 (id) class_getSuperclass(objc_getClass(“Son”)), 函数输出结果是为 Father。<br>第二步：去 Father 这个类里找 - (Class) class, 最后一层层在  NSObject 类中找到。最后内部使用 objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用， 此时已经和 [self class] 调用相同了。</p>
<h4 id="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）">runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h4>
<p>NSObject.h</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">IMP</span>)</span>methodForSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector</span>
</code></pre><p>objc-class.m </p>
<pre><code>IMP class_getMethodImplementation(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>, <span class="title">SEL</span> <span class="title">sel</span>)</span>
</code></pre><p>每一个类对象中管理者一个methodlist,方法列表中记录着方法的名称,方法实现,以及参数类型.</p>
<h4 id="使用runtime_Associate方法关联的对象，需要在主对象dealloc的时候释放么？">使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h4>
<p>无论在MRC下还是ARC下均不需要</p>
<p>对象的内存销毁时间表，分四个步骤</p>
<pre><code>1. 调用 -release ：引用计数变为零
    <span class="keyword">*</span> 对象正在被销毁，生命周期即将结束.
    <span class="keyword">*</span> 不能再有新的 __weak 弱引用， 否则将指向 nil.
    <span class="keyword">*</span> 调用 [self dealloc] 
2. 父类 调用 -dealloc
    <span class="keyword">*</span> 继承关系中最底层的父类 在调用 -dealloc
    <span class="keyword">*</span> 如果是 MRC 代码 则会手动释放实例变量们（iVars）
    <span class="keyword">*</span> 继承关系中每一层的父类 都在调用 -dealloc
3. NSObject 调 -dealloc
    <span class="keyword">*</span> 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
4. 调用 object_dispose()
    <span class="keyword">*</span> 为 C++ 的实例变量们（iVars）调用 destructors 
    <span class="keyword">*</span> 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
    <span class="keyword">*</span> 解除所有使用 runtime Associate方法关联的对象
    <span class="keyword">*</span> 解除所有 __weak 引用
    <span class="keyword">*</span> 调用 free()
</code></pre><h4 id="objc中的类方法和实例方法有什么本质区别和联系？">objc中的类方法和实例方法有什么本质区别和联系？</h4>
<p>类方法：</p>
<ul>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ul>
<p>实例方法：</p>
<ul>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ul>
<h4 id="_objc_msgForward函数是做什么的，直接调用它将会发生什么？">_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h4>
<h4 id="runtime如何实现weak变量的自动置nil？">runtime如何实现weak变量的自动置nil？</h4>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象地址作为 key，当此对象的引用计数为0的时候会 dealloc.假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
<h4 id="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？">能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h4>
<ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
</ul>
<p>解释下：</p>
<p>＋ 编译后的类已经注册在runtime中，类结构体中的 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定，同时 runtime 会调用 class_setIvarLayout 或 class_setWeakivarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>
<ul>
<li>运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。</li>
</ul>
<h4 id="runloop和线程有什么关系？">runloop和线程有什么关系？</h4>
<p>首先 runloop 是一直运行着的循环。run loops 是线程的基础架构部分。每个线程都有与之相对应的 runloop 对象。</p>
<ul>
<li>主线的的runloop默认是开启的</li>
<li>其他线程的runloop是默认没有开启的</li>
</ul>
<h4 id="runloop的mode作用是什么？">runloop的mode作用是什么？</h4>
<p>model 主要是用来指定时间在运行循环中的优先级的<br>苹果公开提供的 Mode 有两个：<br>kCFRunLoopDefaultMode<br>kCFRunLoopCommonModes</p>
<h4 id="以+_scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？">以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h4>
<p>Runloop 只能运行在一种model 下，如果要换mode，当前的runloop也需要停下来重启成新的。利用这个机制，Scrollview滚动过程中NSDefaultRUnllopMode(kCFRunLoopDefaultMode)的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunloopMode模式下处理的事件会影响scrollview的滑动。</p>
<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode(kCFRunLoopDefaultMode)添加到主运行循环中的时候，ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。同时因为mode还是可定制的，所以：Timer 计时会被scrollview的滑动影响的问题可以通过将timer添加到NSRunLoppCommonModes(kCFRunLoopCommonModes)来解决。</p>
<pre><code><span class="comment">//将timer添加到NSDefaultRunLoopMode中</span>
[NSTimer scheduledTimerWithTimeInterval:<span class="number">1.0</span>
     target:<span class="keyword">self</span>
     selector:<span class="keyword">@selector</span>(timerTick:)
     userInfo:<span class="literal">nil</span>
     repeats:<span class="literal">YES</span>];
<span class="comment">//然后再添加到NSRunLoopCommonModes里</span>
NSTimer *timer = [NSTimer timerWithTimeInterval:<span class="number">1.0</span>
     target:<span class="keyword">self</span>
     selector:<span class="keyword">@selector</span>(timerTick:)
     userInfo:<span class="literal">nil</span>
     repeats:<span class="literal">YES</span>];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre><h4 id="猜想runloop内部是如何实现的？">猜想runloop内部是如何实现的？</h4>
<pre><code><span class="title">while</span> (date &lt; untileDate) {
    <span class="title">id</span> event = listenEvent (); 
    <span class="title">handleEvent</span> (v);
}
</code></pre><h4 id="objc使用什么机制管理对象内存？">objc使用什么机制管理对象内存？</h4>
<p>通过 retainCount 的机制来决定对象是否需要释放每次 runloop 的时候，都会检查对象的retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>
<h4 id="ARC通过什么方式帮助开发者管理内存？">ARC通过什么方式帮助开发者管理内存？</h4>
<p>编译时根据代码上下文，插入 retain/release </p>
<h4 id="不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）">不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h4>
<p>在每次 eventloop 开始创建自动创建释放池， 在每次事件结束销毁自动释放池。<br>以 viewDidLoad 方法为例，在viewDidLoad方法开始执行之前创建自动释放池,在viewDidAppear方法执行之后销毁自动释放池。</p>
<h4 id="BAD_ACCESS在什么情况下出现？">BAD_ACCESS在什么情况下出现？</h4>
<ul>
<li>访问了野指针</li>
<li>死循环</li>
</ul>
<h4 id="苹果是如何实现autoreleasepool的？">苹果是如何实现autoreleasepool的？</h4>
<p>autoreleasepool以一个队列数组的形式实现，主要通过下列三个函数完成.</p>
<ul>
<li>objc_autoreleasepoolPush</li>
<li>objc_autoreleasepoolPop</li>
<li>objc_autorelease</li>
</ul>
<p>对autorelease分别执行push，和pop操作。销毁对象时执行release操作。</p>
<h4 id="使用block时什么情况会发生引用循环，如何解决？">使用block时什么情况会发生引用循环，如何解决？</h4>
<p>一个对象对 block 进行了强引用，而在 block 内部有直接使用到该对象。</p>
<p>声明一个 weak 的对象指向该对象， 在 block 内部使用该 weak 对象。</p>
<pre><code><span class="keyword">id</span> <span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>; 或者 <span class="keyword">weak</span> __<span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>该方法可以设置宏
<span class="keyword">id</span> __block weakSelf = <span class="keyword">self</span>;
</code></pre><h4 id="在block内如何修改block外部变量？">在block内如何修改block外部变量？</h4>
<p>默认情况下，在block中访问的外部变量时复制过去的，既：写操作不对原变量生效。但是可以通过加上__block修饰外部变量。</p>
<pre><code>__block <span class="keyword">int</span> a = <span class="number">0</span>;
<span class="keyword">void</span>  (^foo)(<span class="keyword">void</span>) = ^{ 
    a = <span class="number">1</span>; 
}
f00();
</code></pre><p>实现原理，简单来讲，外部变量通过指针传递，将变量传递到 block 内，所以可以修改变量值。</p>
<h4 id="使用系统的某些block_api（如UIView的block版本写动画时），是否也考虑引用循环问题？">使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h4>
<p>NO, since self will be captured in the block which is dispatched asynchronously, self will be implicity retained, and released again when the block has been finished.</p>
<p>That means, the life-time of self will be extended  up until after the block finishes.</p>
<h4 id="GCD的队列（dispatch_queue_t）分哪两种类型？">GCD的队列（dispatch_queue_t）分哪两种类型？</h4>
<ul>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ul>
<h4 id="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）">如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h4>
<p>使用 Dispatch Group 追加block到Global Group Queue，这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block</p>
<pre><code>dispatch_queue_t <span class="built_in">queue</span> <span class="subst">=</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);
dispatch_group_t <span class="keyword">group</span> <span class="subst">=</span> dispatch_group_create();
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{ <span class="comment">/*加载图片1 */</span> });
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{ <span class="comment">/*加载图片2 */</span> });
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{ <span class="comment">/*加载图片3 */</span> }); 
dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^{
        <span class="comment">// 合并图片</span>
});
</code></pre><h4 id="dispatch_barrier_async的作用是什么？">dispatch_barrier_async的作用是什么？</h4>
<p>在并行队列中，为了保持某些任务的顺序，需要等待一些人物完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async<br>追加的处理执行结束之后，Concurrent Dispatch Queue 才恢复之前的动作继续执行。</p>
<pre><code><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"test_queue"</span>, DISPATCH_QUEUE_CONCURRENT);  
<span class="built_in">dispatch_async</span>(queue, ^{  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_async1"</span>);  
});  
<span class="built_in">dispatch_async</span>(queue, ^{  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4</span>];  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_async2"</span>);  
});  
dispatch_barrier_async(queue, ^{  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_barrier_async"</span>);  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4</span>];  

});  
<span class="built_in">dispatch_async</span>(queue, ^{  
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];  
    <span class="built_in">NSLog</span>(<span class="string">@"dispatch_async3"</span>);  
}); 
</code></pre><h4 id="苹果为什么要废弃dispatch_get_current_queue？">苹果为什么要废弃dispatch_get_current_queue？</h4>
<p>dispatch_get_current_queue容易造成死锁</p>
<h4 id="以下代码运行结果如何？">以下代码运行结果如何？</h4>
<pre><code>- (void)viewDidLoad
{
    <span class="attr_selector">[super viewDidLoad]</span>;
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"1"</span>);</span>
    <span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"2"</span>);</span>
    });
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"3"</span>);</span>
}
</code></pre><p>只输出：1 。发生主线程锁死。原因是主队列在等待 dispatch_sync(dispatch_get_main_queue(), ^{NSLog(@”2”);});执行。dispatch_sync 在等待著队列执行完毕，造成死锁。</p>
<h4 id="addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？">addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h4>
<pre><code><span class="comment">// 添加键值观察</span>
<span class="comment">/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
*/</span>
[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:@<span class="string">"name"</span> options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@<span class="string">"Person Name"</span>];
</code></pre><p>observer中需要实现以下方法：</p>
<pre><code><span class="comment">// 所有的 kvo 监听到事件，都会调用此方法</span>
<span class="comment">/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */</span>
- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context;
</code></pre><h4 id="如何手动触发一个value的KVO">如何手动触发一个value的KVO</h4>
<p>所谓的“手动触发”是区别于”自动触发：<br>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。想知道如何手动触发，就得搞明白自动触发 KVO 的原理：</p>
<p>键值观察通知依赖于 NSObject 的两个方法： willChangeValueForKey: 和 didChangeValueForKey:。在一个被观察属性发生改变之前，willChangeValueForKey:一定会被调用，这就会记录旧的值。而当改变发生之后，didChangeValueForKey:会被调用，继而observeValueForKey:ofObject:change:context也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了；</p>
<p>那么”手动触发“的使用场景是什么？一般我们只在希望能控制”回调的调用时机”时才会这么做。</p>
<p>具体做法如下：</p>
<p>如果这个value是表示时间的 self.now,那么代码如下：</p>
<pre><code><span class="comment">//@property (nonatomic, strong) NSDate *now;</span>
- (<span class="keyword">void</span>)viewDidLoad
{
    [<span class="keyword">super</span> viewDidLoad];
    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"now"</span>]; <span class="comment">// “手动触发self.now的KVO”，必写。</span>
    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"now"</span>]; <span class="comment">// “手动触发self.now的KVO”，必写。</span>
}
</code></pre><p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>
<p>比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。</p>
<h4 id="若一个类有实例变量NSString_*_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？">若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h4>
<p>Both</p>
<h4 id="KVC的keyPath中的集合运算符如何使用？">KVC的keyPath中的集合运算符如何使用？</h4>
<ul>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有 @avg, @count, @max, @min, @sum</li>
<li>格式 @”sum.age”或@”集合属性.@max.age”</li>
</ul>
<h4 id="KVC和KVO的keyPath一定是属性么？">KVC和KVO的keyPath一定是属性么？</h4>
<p>KVO支持实例变量</p>
<h4 id="如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？">如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h4>
<h4 id="apple用什么方式实现对一个对象的KVO？">apple用什么方式实现对一个对象的KVO？</h4>
<p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的setter方法。重写setter方法会负责在调用原setter方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写 （isa-swizzling）把这个对象的 isa 指针（isa指针告诉Runtime系统这个对象的类是什么）指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。</p>
<p>详细解释：</p>
<p>键值观察者通知依赖于NSObject的两个方法： willChangeValueForKey: and didChangeValueForKey: 。在一个被观察属性发生改变之前, willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当发生改变之后，didChangeValueForKey:会被调用，继而observerValueForKey:ofObject:change:context:也会被调用。可以手动实现这些调用，但很少这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>
<h4 id="IBOutlet连出来的视图属性为什么可以被设置成weak?">IBOutlet连出来的视图属性为什么可以被设置成weak?</h4>
<p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了</p>
<h4 id="IB中User_Defined_Runtime_Attributes如何使用？">IB中User Defined Runtime Attributes如何使用？</h4>
<p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>
<h4 id="如何调试BAD_ACCESS错误">如何调试BAD_ACCESS错误</h4>
<ul>
<li>From the Scheme toolbar menu, choose a scheme.</li>
<li>From the same menu, choose Edit Scheme to display the scheme dialog</li>
<li>In the left column, select run</li>
<li>To specify runtime diagnostics,click the Diagnostics tab.</li>
<li>For debug BAD_ACCESS, enable the Enable Zombie Objects checkbox.</li>
<li>Click Close</li>
<li>Click the Run button or chosse Product &gt; Run</li>
</ul>
<h4 id="lldb（gdb）常用的调试命令？">lldb（gdb）常用的调试命令？</h4>
<p><code>po</code> <code>expression</code> <code>call</code> <code>thread return &lt;RETURN EXPRESSION&gt;</code> <code>b</code> <code>thread backtrace</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/07/23/oc-checklist-answers/" data-id="9nv247pbbc4yvyn0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nsstring-property-copy-or-retain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/07/19/nsstring-property-copy-or-retain/">从 NSString Property:copy or retain 到 NSCopying</a>
  

      </header>
    
    <time class="article-date" datetime="2015-07-19T03:50:04.000Z" itemprop="datePublished">07-19-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tech/">Tech</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="NSString_Property:copy_or_retain">NSString Property:copy or retain</h4>
<p>iOS程序中，在定义对象属性的时候，我们一般会把<code>NSString</code>类型的属性的修饰符写成 <code>copy</code>， 而不是 <code>retain</code> (或者 ARC 下面的 <code>strong</code>)。</p>
<p><strong>为什么会有<code>NSString</code>要用<code>copy</code>来修饰的convention？能否用 <code>strong</code>代替?</strong></p>
<p>回答这个问题之前，我们先看段代码：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">Fruit</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)     <span class="built_in">NSString</span>  * fruitNameCopy;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)   <span class="built_in">NSString</span>  * fruitNameStrong;
<span class="keyword">@end</span>

<span class="built_in">NSMutableString</span> * fruitName = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"apple"</span>];

Fruit * fruit = [[Fruit alloc] init];
fruit<span class="variable">.fruitNameCopy</span>     = fruitName;
fruit<span class="variable">.fruitNameStrong</span>   = fruitName;

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName); <span class="comment">// 0x7fddabd0e250  apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>); <span class="comment">// 0xa0000656c7070615 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>); <span class="comment">// 0x7fddabd0e250  apple</span>

<span class="comment">//fruitName =@"pear";</span>
[fruitName setString: <span class="string">@"pear"</span>];

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName); <span class="comment">// 0x7fddabd0e250  pear</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>); <span class="comment">// 0xa0000656c7070615 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>); <span class="comment">// 0x7fddabd0e250  pear</span>
</code></pre><p>该段程序运行到结尾时， fruitNameCopy 的值是 apple，fruitNameCopy 的值是 pear，且两者的内存地址也不一样。<br>程序中，当我们对一个mutable对象做<code>copy</code>操作的时候，objc runtime 会用一次<a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="external">深拷贝</a>来处理， runtime 会重新分配一块内存地址空间，并把原mutable对象的值拷贝过来。所以打印出来的 fruitNameCopy 和 fruitNameStrong 的内存地址是不一样的。而这之后在对 fruitName 做任何的赋值操作都只能作用于 fruitNameStrong.</p>
<p><strong>那如果我们把 fruitName 改成 immutable 的会是怎样的了？</strong></p>
<pre><code><span class="built_in">NSString</span> * fruitName = <span class="string">@"apple"</span>;

Fruit * fruit = [[Fruit alloc] init];
fruit<span class="variable">.fruitNameCopy</span>     = fruitName;
fruit<span class="variable">.fruitNameStrong</span>   = fruitName;

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName);<span class="comment">// 0x10e27b078 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>);<span class="comment">// 0x10e27b078 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>);<span class="comment">// 0x10e27b078 apple</span>

fruitName =<span class="string">@"pear"</span>;

<span class="built_in">NSLog</span>(<span class="string">@"fruitName: %p %@"</span>, fruitName, fruitName);<span class="comment">// 0x10e27b0f8 pear</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameCopy: %p %@"</span>, fruit<span class="variable">.fruitNameCopy</span>,  fruit<span class="variable">.fruitNameCopy</span>);<span class="comment">// 0x10e27b078 apple</span>
<span class="built_in">NSLog</span>(<span class="string">@"fruitNameStrong:%p  %@"</span>, fruit<span class="variable">.fruitNameStrong</span>, fruit<span class="variable">.fruitNameStrong</span>);<span class="comment">// 0x10e27b078 apple</span>
</code></pre><p>结果是 fruitName, fruitNameCopy, fruitNameStrong 三者的地址都是一样的。按理说<code>copy</code>动作是深拷贝，fruitNameCopy指向的地址 应该是新分配的内存地址才对。<br>那为什么打印出来的地址却是同一个地址了？答案是 runtime 在这里做一个性能优化，@”apple” 是一个immutable的值，没有必要做一次深拷贝，直接做一次 retain 就达到目的了。</p>
<p><strong>试试看把<code>NSString</code>替换成<code>NSArray</code></strong></p>
<p>对象 Fruit 中添加两个属性<br>    @property (nonatomic, copy)     NSArray  <em> placesCopy;<br>    @property (nonatomic, strong)   NSArray  </em> placesStrong;</p>
<p>先用 mutable 的变量试试</p>
<pre><code><span class="built_in">NSMutableArray</span> * places = [<span class="built_in">NSMutableArray</span> arrayWithArray:@[<span class="string">@"china"</span>, <span class="string">@"japan"</span>]];
fruit<span class="variable">.placesCopy</span>    = places; <span class="comment">//placesCopy: 0x7f8f18d0c4f0 (china,japan)</span>
fruit<span class="variable">.placesStrong</span>  = places; <span class="comment">//placesStrong: 0x7f8f18d51a80 (china,japan)</span>

[places addObject:<span class="string">@"korea"</span>];
<span class="comment">//placesCopy: 0x7f8f18d0c4f0 (china,japan)</span>
<span class="comment">//placesStrong: 0x7f8f18d51a80 (china,japan, korea)</span>
</code></pre><p>再用 immutable 的变量试试</p>
<pre><code><span class="constant">NSArray * places</span> = @[@<span class="string">"china"</span>, @<span class="string">"japan"</span>];

fruit.placesCopy    = places; <span class="comment">//placesCopy: 0x7fc4e8c6f2a0 (china,japan)</span>
fruit.placesStrong  = places; <span class="comment">//placesStrong: 0x7fc4e8c6f2a0 (china,japan)</span>

places = @[@<span class="string">"uk"</span>, @<span class="string">"us"</span>];
<span class="comment">//placesCopy: 0x7fc4e8c6f2a0 (china,japan)</span>
<span class="comment">//placesStrong: 0x7fc4e8c6f2a0 (china,japan)</span>
</code></pre><p>实验结果和 <code>NSString</code> 是一致的。</p>
<h4 id="NSCopying">NSCopying</h4>
<p>如果你愿意，你可以试试看其他容器类 <code>NSDictionary</code>, <code>NSSet</code>,<code>NSIndexSet</code>， 会发现结果也保持一致。我们尝试解读这些类的头文件，作进一步的探索。以下是这些类头文件的节选：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSFastEnumeration</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span>&lt;<span class="title">__covariant</span> <span class="title">KeyType</span>, <span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSFastEnumeration</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSSet</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSFastEnumeration</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSIndexSet</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">NSIndexPath</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span>
</code></pre><p>会发现这些类都实现了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSCopying_Protocol/index.html" target="_blank" rel="external"><code>NSCoying</code></a>协议.在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSCopying_Protocol/index.html" target="_blank" rel="external"><code>NSCoying</code></a>文档中有关于实现该协议的三条准则，其中第三条是：</p>
<pre><code>Implement NSCopying <span class="keyword">by</span> retaining <span class="operator">the</span> original instead <span class="operator">of</span> creating <span class="operator">a</span> <span class="built_in">new</span> copy when <span class="operator">the</span> class <span class="operator">and</span> its contents are immutable.
</code></pre><p>这条准则很好的解释了上面的试验结果，让这些结果讲得通。</p>
<h4 id="Summary">Summary</h4>
<p><strong>综上，当我们使用<code>copy</code>来修饰<code>NSString</code>等容器类的属性时，如果被拷贝的对象是 Mutable， 则 runtime 会做深拷贝， 如果是 Immutable， 则runtime只是做一次 <code>retain</code>。</strong></p>
<p><strong>如果在程序中我们自己定义的类也需要实现 <code>NSCopying</code> 协议时，务必也要遵照此规则：若被拷贝的原对象是 Immutable 的，则无需新建一个拷贝，只需要 retian 原对象一次；若原对象是 mutablde 的，则需做一次深拷贝，新建一个对象</strong></p>
<p><strong>如果在程序中，你需要避免一个对象的某个属性被反向更改 (prevent mutating an object’s attributes behind its back)，请把该属性标记成 <code>copy</code></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/07/19/nsstring-property-copy-or-retain/" data-id="mozka2wtmzp3oukx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-movie-list-been-watched-2015-1st" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/07/13/movie-list-been-watched-2015-1st/">2015上半年看过的电影</a>
  

      </header>
    
    <time class="article-date" datetime="2015-07-13T14:40:09.000Z" itemprop="datePublished">07-13-2015</time>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Movie/">Movie</a>
  </div>

  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>中国</strong></p>
<ul>
<li>一步之遥 </li>
</ul>
<p><strong>United States</strong></p>
<ul>
<li>Chirldhood</li>
<li>Nebraska</li>
<li>August Osage County</li>
<li>American Sniper</li>
<li>Birdman</li>
<li>2001: A Space Odyssey</li>
<li>Driving Miss Daisy</li>
<li>The Maze Runner</li>
<li>Big Hero 6</li>
<li>Lost In Translation</li>
<li>Fast &amp; Furious 7</li>
</ul>
<p><strong>Japan</strong></p>
<ul>
<li>Seven Samurai</li>
<li>Little Forest Natsu Aki</li>
<li>The Little House</li>
<li>Our Mother</li>
</ul>
<p><strong>Korea</strong></p>
<ul>
<li>Snowpiercer</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/07/13/movie-list-been-watched-2015-1st/" data-id="u0rks3jtxh0g1o6r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-za-huo-che-de-ren" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/07/05/za-huo-che-de-ren/">砸火车的人</a>
  

      </header>
    
    <time class="article-date" datetime="2015-07-05T06:52:27.000Z" itemprop="datePublished">07-05-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://cp0000.github.io/assets/kite-runner.jpg" alt="kite-runner"></p>
<p>罗素在《幸福之路》一书中有一节是讨论关于<code>厌烦与兴奋</code>的。里面说到现代人对比我们的祖先更少厌烦，但却更怕厌烦。我们进行听音乐，玩电子游戏，看电影，或许都是为了消除厌烦吧。甚至有时候，我觉得读书也是消除厌烦，而不是为了获取知识。</p>
<p>我一直把自己当作一个喜欢读书的人来对待，但事实上我读过的书很少。</p>
<p>当然需要说明的是，我这里指的书籍是剔除了上学时候的教科书，工作之后的专业书籍。对我而言，这些书大都有一些不得不去读的意味，为了升学，为了升职，为了生存。要从这类书籍中要获取到乐趣是不太容易的。所以我这里读的书指的是一些“闲书”，纯粹因个人喜好而去看的书。</p>
<p>为了消除厌烦，我们总是希望能够从同样喜欢读书且品味没那么糟糕的人口中获得一些推荐的书籍，以备我们无聊的时候可以用来打发时间。记得上大学的时候，我总是喜欢推荐一本叫《追风筝的人》的书给其他人以换取其他人的推荐。书很薄，读起来很流畅，不会觉的累，故事精彩缺让人回味无穷。今天我抄袭此书的名字，取名这篇文章叫《砸火车的人》，来回忆一段同样是年少时发生的一件不光彩的事迹。</p>
<p>我一直是一个本分，胆子不大的人。小时候，可能是由于年纪原因，我也算是村庄里面孩子的头头。我们几个人早上一起上学，放学一起玩弹珠，打打扑克。映像中聚众打架，偷庄稼这种事情可能也就干过一两次。我们阵容很小，稳定的阵容只有我，弟弟，黑皮，还有几个经常一起玩，但是不是固定阵容的。黑皮那个时候跟我们玩的最好，上小学的时候我们总是在一起玩，砸火车的事情也是我们一起干的。</p>
<p>有段时间，黑皮说他跟其他人一起去村子旁边的火车道上砸过火车，很好玩。我当时一是好奇心作祟，二是自尊心要强，于是说我们也要去砸火车。<br>于是在某个无所事事的周末下午，我，弟弟，黑皮加上另外两三个人，不记得是谁了。一道去了村旁边的火车道上准备砸火车。来到火车道上，我们在旁边埋伏好，过了一伙儿，一列货车就缓缓驶了过来。等火车头经过我们的时候，黑皮立马从地上捡起石头砸向火车头，剩下的人看此情况，于是也都纷纷捡起石头砸向火车。不一会儿，火车就开走了，我们玩的很开心，有时候你很难搞清楚为啥我们对搞破坏是如此的感兴趣。然而出乎意料的事情发生了，火车在不远去停了下来，尽然倒退了。我们几个当时年纪都很小，我最大，也才上小学三年级，一下子就慌了。火车里面的人是要回来逮捕我们，怎么办。慌乱中，我们往旁边的山头上跑，在一个沟渠里面躲了起来。自然，9岁小孩的毛把戏，是逃不过这帮开火车大人的眼睛的。他们很快就把我们揪了出来。我记得当时自己全身都在发抖，很害怕。那帮家伙要把我们拎上火车，然后带走。至于去哪里，天知道。我只记得我拼命的说火车头不是我砸的，不是我砸的，我没有砸前面的火车头。事态发展的太快，然后矛头不知怎么着就指向了黑皮，我和其他几个人都说是他砸的，出卖了黑皮，为了保全自己；但那个时候火车里面的人搞错了，以为我们说的是我弟弟，便拉着我弟弟要上火车；我很害怕，不知该怎么办，但是我没敢上去阻止，只是在旁边大声说不是我弟弟，是黑皮，毫无保留的把黑皮卖掉了。然后黑皮被他们拖上了火车，就要被带走了。被火车带走，对于一个9岁的孩子来说，可能跟死亡也没啥区别吧。</p>
<p>幸好这个时候在田里面干活的农人都赶了过来，大伙儿一起劝说火车上的那帮家伙，大概是些小孩子不懂事之类的，好说歹说黑皮终于没有被带走，算是幸免于难。不过火车上的那帮家伙还是把黑皮的名字，家庭地址，学校记了下来，后面还把这件事通报到学校，黑皮被批评了一番。</p>
<p>每次回想起这件事情，我都为自己的不道义感到害臊。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cp0000.github.io/2015/07/05/za-huo-che-de-ren/" data-id="lwuq9wh0lwswuk1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Pei Cheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63703524-1', 'auto');
  ga('send', 'pageview');

</script>
  </div>
</body>
</html>